<!-- build time:Sun Nov 03 2024 09:38:06 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="how" href="https://how2051.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="how" href="https://how2051.github.io/atom.xml"><link rel="alternate" type="application/json" title="how" href="https://how2051.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="CPP新特性,CPP17,CPP11"><link rel="canonical" href="https://how2051.github.io/2024/10/12/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><title>C++ 多线程 - C++ - 编程 | R1ck's Playground = how</title><meta name="generator" content="Hexo 7.0.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C++ 多线程</h1><div class="meta"><span class="item" title="创建时间：2024-10-12 19:24:45"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-10-12T19:24:45+08:00">2024-10-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>20k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>18 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">R1ck's Playground</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="item" rel="index" title="分类于 编程"><span itemprop="name">编程</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%BC%96%E7%A8%8B/C/" itemprop="item" rel="index" title="分类于 C++"><span itemprop="name">C++</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://how2051.github.io/2024/10/12/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Rick how"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="how"></span><div class="body md" itemprop="articleBody"><h3 id="一-intro"><a class="anchor" href="#一-intro">#</a> 一、Intro</h3><p>完全无任何线程同步措施，线程会相互竞争打断，本例中，线程 A 的操作无法保证完整性：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;===============================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread A: do somethingA 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread A: do somethingA 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread A: do somethingA 3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;== Thread B: do somethingB ==&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>每个线程操作公共资源前先加锁再操作，可以保证对资源的访问不会被打断，但无协调同步：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;===============================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread A: do somethingA 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread A: do somethingA 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread A: do somethingA 3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;== Thread B: do somethingB ==&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>加入条件变量进行协同，A 线程在完成处理后通知 B 线程：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;===============================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread A: do somethingA 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread A: do somethingA 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread A: do somethingA 3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();	<span class="comment">// 在上面 lock_guard 自动解锁后，在这里通知线程 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock); <span class="comment">// 等待条件满足，即等待线程 A 操作完毕</span></span><br><span class="line">            <span class="comment">// 在等待期间，互斥锁会被释放</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;== Thread B: do somethingB ==&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但如果 A 线程的速度很快，A 线程仍然会多次竞争到锁然后多次访问资源、多次 notify 线程 B，尽管线程 B 具备访问公共资源的条件（条件变量成立），但常常会被线程 A 抢占 —— 除非线程 A 通过 sleep 休眠来放弃 CPU。<p></p><p>这里只要让线程 A 稍微休眠仅仅 1 ms，线程 B 就能立刻抢占到 CPU，又加之条件变量的条件满足，故线程 B 得以访问公共资源：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;===============================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread A: do somethingA 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread A: do somethingA 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Thread A: do somethingA 3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();	<span class="comment">// 在上面 lock_guard 自动解锁后，在这里通知线程 B</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock); <span class="comment">// 等待条件满足，即等待线程 A 操作完毕</span></span><br><span class="line">            <span class="comment">// 在等待期间，互斥锁会被释放</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;== Thread B: do somethingB ==&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>与之相反的是，线程 B 并不会由于频繁调用而持续占用 CPU，因为其调用的 <code>wait</code> 函数会阻塞并等待互斥锁可用，此时其将放弃 CPU。<p></p><h3 id="二-常见场景"><a class="anchor" href="#二-常见场景">#</a> 二、常见场景</h3><h5 id="1-a-线程和-b-线程轮流执行互为条件"><a class="anchor" href="#1-a-线程和-b-线程轮流执行互为条件">#</a> 1、A 线程和 B 线程轮流执行，互为条件</h5><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> isThreadAturn = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFuncA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(!isThreadAturn) &#123;</span><br><span class="line">                cv.<span class="built_in">wait</span>(lck);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;in threadFuncA====: 3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;in threadFuncA====: 4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            isThreadAturn = <span class="literal">false</span>;</span><br><span class="line">            cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFuncB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(isThreadAturn) &#123;</span><br><span class="line">                cv.<span class="built_in">wait</span>(lck);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;====in threadFuncB: 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;====in threadFuncB: 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            isThreadAturn = <span class="literal">true</span>;</span><br><span class="line">            cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">threadA</span><span class="params">(threadFuncA)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">threadB</span><span class="params">(threadFuncB)</span></span>;</span><br><span class="line"></span><br><span class="line">    threadA.<span class="built_in">join</span>();</span><br><span class="line">    threadB.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="2-a-线程执行一次后b-线程执行多次轮流执行"><a class="anchor" href="#2-a-线程执行一次后b-线程执行多次轮流执行">#</a> 2、A 线程执行一次后，B 线程执行多次，轮流执行</h5><h5 id="3-a-线程执行多次后b-线程执行一次轮流执行"><a class="anchor" href="#3-a-线程执行多次后b-线程执行一次轮流执行">#</a> 3、A 线程执行多次后，B 线程执行一次，轮流执行</h5><h5 id="4-a-线程执行多次后b-线程执行多次轮流执行"><a class="anchor" href="#4-a-线程执行多次后b-线程执行多次轮流执行">#</a> 4、A 线程执行多次后，B 线程执行多次，轮流执行</h5><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFuncA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(!isThreadAturn) &#123;</span><br><span class="line">                cv.<span class="built_in">wait</span>(lck);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;in threadFuncA====: 3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;in threadFuncA====: 4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">4</span>) &#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                isThreadAturn = <span class="literal">false</span>;</span><br><span class="line">                cv.<span class="built_in">notify_one</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上三种情况只需要在各自线程中维护一个 cnt 变量即可，只有运行一定次数后再去 notify 其他线程。<p></p><h5 id="5-a-线程执行到某个节点后需要等待-b-线程执行到某个节点然后-a-线程再执行"><a class="anchor" href="#5-a-线程执行到某个节点后需要等待-b-线程执行到某个节点然后-a-线程再执行">#</a> 5、A 线程执行到某个节点后需要等待 B 线程执行到某个节点，然后 A 线程再执行</h5><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isConditionMeet = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!isConditionMeet) &#123;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;===============================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread A: do somethingA 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread A: do somethingA 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread A: do somethingA 3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();	<span class="comment">// 在上面 lock_guard 自动解锁后，在这里通知线程 B</span></span><br><span class="line">    isConditionMeet = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;== in thread b, some pre process&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        isConditionMeet = <span class="literal">true</span>;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">        cv.<span class="built_in">wait</span>(lock); <span class="comment">// 等待条件满足，即等待线程 A 操作完毕</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在等待期间，互斥锁会被释放</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;== Thread B: do somethingB ==&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>利用条件变量，维护一个全局的布尔变量，用于控制 A、B 线程的先后运行顺序（先运行 B 线程），然后在需要协同的某个节点开始 wait，等待另一个线程执行完需要的依赖然后 notify。这里其实用两个条件变量更加便于理解且清晰。<p></p><h5 id="6-a-线程执行到某个节点后需要等待-b-线程执行到某个节点然后一起继续执行"><a class="anchor" href="#6-a-线程执行到某个节点后需要等待-b-线程执行到某个节点然后一起继续执行">#</a> 6、A 线程执行到某个节点后需要等待 B 线程执行到某个节点，然后一起继续执行</h5><p>B 线程到了相应节点后，notify A 线程，自己则照常继续往下执行即可。<br>A 线程 wait 等待 B 线程执行到相应的节点然后接收到通知后往下执行。<br>用到一个 mutex 和一个 condition_variable，可以不需要维护一个全局的布尔变量。</p><h3 id="三-相关函数"><a class="anchor" href="#三-相关函数">#</a> 三、相关函数</h3><h5 id="1-stdcondition_variable"><a class="anchor" href="#1-stdcondition_variable">#</a> 1、std::condition_variable</h5><p><code>std::condition_variable</code> 是 C++ 标准库中的一种线程同步原语，用于实现线程之间的协作和通信。它通常与互斥锁（ <code>std::mutex</code> ）一起使用，用于阻塞一个或多个线程，直到另一个线程修改了共享变量（条件）并通知了 <code>condition_variable</code> 。</p><p>想要修改共享变量的线程必须满足以下条件：<br>1. 获取一个 <code>std::mutex</code> 互斥锁（典型例子是通过 <code>std::lock_guard</code> ）<br>2. 当持有锁时修改该共享变量<br>3. 利用条件变量调用 <code>notify_one</code> 或者 <code>notify_all</code> （可以先释放锁再 notify）</p><p>想要等待条件变量的线程必须满足以下条件：<br>1. 获取用于保护共享变量的 <code>std::unique_lock&lt;std::mutex&gt;</code><br>2. 执行以下操作中的任意一个：<br>检测条件变量是否被 notify<br>利用条件变量调用 wait 函数（会自动释放锁并挂起线程，直到被 notify 或时间到期或虚假唤醒）<br>如果条件不满足则继续等待</p><h6 id="astdcondition_variablewait"><a class="anchor" href="#astdcondition_variablewait">#</a> a）std::condition_variable::wait</h6><p>wait 会阻塞当前线程，直到条件变量被 notify（或发生虚假唤醒），有两种重载形式：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Predicate &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate stop_waiting )</span></span>;</span><br></pre></td></tr></table></figure><p></p><p><mark>当一个条件变量调用 wait 函数时，会自动释放当前已经持有的锁，然后阻塞当前线程，等待条件变量被 notify</mark>。当 <code>notify_one</code> 或 <code>notify_all</code> 被执行后，线程会被解除阻塞。<mark>当被解除阻塞后，在 wait 函数退出前，锁会被重新获取</mark>。</p><p>第二种重载形式相较于第一种，多了一个谓词作为条件，其含义为：<mark>当条件不满足时，将持续等待</mark>。其能够有效避免虚假唤醒。</p><p>第二种重载形式等价于：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">stop_waiting</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">wait</span>(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这意味着：<br>1.<mark> 当第一次调用 wait 时，如果条件为真，不会发生阻塞，不需要 notify 就能继续执行后续代码</mark><br>2. 一旦阻塞发生，则必须等待 notify 以解除阻塞，光是条件为真不管用<br>3.<mark> 如果被 notify 了，不一定会解除阻塞，需要进一步判断条件是否为真</mark>，以防止虚假唤醒</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> isReady = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            isReady = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();	<span class="comment">// 在上面 lock_guard 自动解锁后，在这里通知线程 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> isReady; &#125;); <span class="comment">// 等待条件满足</span></span><br><span class="line">            <span class="comment">// 在等待期间，互斥锁会被释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h6 id="bstdcondition_variablewait_for"><a class="anchor" href="#bstdcondition_variablewait_for">#</a> b）std::condition_variable::wait_for</h6><p>和 wait 相似，有两个重载版本：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep, <span class="keyword">class</span> Period &gt;</span></span><br><span class="line"><span class="function">std::cv_status <span class="title">wait_for</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time )</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep, <span class="keyword">class</span> Period, <span class="keyword">class</span> Predicate &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_for</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time,</span></span></span><br><span class="line"><span class="params"><span class="function">               Predicate stop_waiting )</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>与 wait 不同的是， <code>wait_for</code> 允许线程在等待条件一段时间后<mark>自动醒来，即使条件尚未满足</mark>。线程可以指定一个时间段作为参数，如果在指定时间内条件未满足，线程将自动醒来。</p><p>另外，wait_for 具有函数返回值，用于区分是否超时、是否满足条件：<br>对于第一种重载版本：<br>返回 <code>std::cv_status::timeout</code> 如果超时了<br>返回 <code>std::cv_status::no_timeout</code> 如果未超时<br>对于第二种重载版本：<br>返回 false 如果超时后条件仍未满足（ <code>stop_waiting</code> 仍为 false），否则返回 true</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> isReady = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            isReady = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();	<span class="comment">// 在上面 lock_guard 自动解锁后，在这里通知线程 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">auto</span> timeout = std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>);</span><br><span class="line">            std::cv_status status = cv.<span class="built_in">wait_for</span>(lock, timeout, [] &#123; <span class="keyword">return</span> isReady; &#125;);</span><br><span class="line">            <span class="keyword">if</span> (status == std::cv_status::no_timeout) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Main thread: Condition is met.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Main thread: Timeout occurred.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h6 id="cstdcondition_variablenotify_one-and-notify_all"><a class="anchor" href="#cstdcondition_variablenotify_one-and-notify_all">#</a> c）std::condition_variable::notify_one and notify_all</h6><p>唤醒等待在当前条件变量的任意一个线程或所有线程。</p><h5 id="2-lock_guard"><a class="anchor" href="#2-lock_guard">#</a> 2、lock_guard</h5><p>#CPP 新特性 #CPP11<br><code>std::lock_guard</code> 是 C++ 标准库中的一个类，用于管理互斥锁（mutex）的自动加锁和解锁操作。它是 C++11 引入的一部分，旨在简化多线程编程中的锁管理，以防止忘记在离开作用域时解锁互斥锁，从而避免死锁等问题</p><p><code>std::lock_guard</code> 具有以下主要特点和用途：</p><ol><li><strong>自动加锁和解锁</strong>：当创建 <code>std::lock_guard</code> 对象时，它会自动锁定关联的互斥锁；当 <code>std::lock_guard</code> 对象离开其作用域时（例如，通过函数返回或作用域结束），它会自动释放锁。</li><li><strong>异常安全</strong>： <code>std::lock_guard</code> 提供了异常安全性，即使在作用域中抛出异常，也会在作用域结束时正确释放锁，从而防止资源泄漏。</li><li><strong>简化代码</strong>：使用 <code>std::lock_guard</code> 可以大大简化管理互斥锁的代码，避免了手动加锁和解锁，减少了程序出错的可能性。</li></ol><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">//加锁后的一些操作</span></span><br><span class="line">&#125;<span class="comment">//当离开当前作用域，自动解锁</span></span><br></pre></td></tr></table></figure><p></p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工程中实际应用</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置tick=0，避免泊车切行车时发送旧的结果</span></span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; <span class="built_in">lk</span>(m_mutex_latest_fusion_res);</span><br><span class="line">        m_latest_fusion_res-&gt;<span class="built_in">set_tick</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>需要注意的是， <code>std::lock_guard</code> 通常是一个更安全和方便的替代品，而不是手动使用 <code>std::unique_lock</code> 或 <code>std::lock</code> 函数。它是一种简单的 <span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL3JhaWk=">RAII</span>（资源获取即初始化）包装，可用于管理互斥锁的生命周期。</p><p>参考链接：<br><span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL3RocmVhZC9sb2NrX2d1YXJkIzp+OnRleHQ9VGhlJTIwY2xhc3MlMjBsb2NrX2d1YXJkJTIwaXMlMjBhJTIwbXV0ZXglMjB3cmFwcGVyJTIwdGhhdCx0YWtlJTIwb3duZXJzaGlwJTIwb2YlMjB0aGUlMjBtdXRleCUyMGl0JTIwaXMlMjBnaXZlbg==">std: :lock_guard</span></p><h5 id="3-unique_lock"><a class="anchor" href="#3-unique_lock">#</a> 3、unique_lock</h5><p><code>std::unique_lock</code> 是 C++ 标准库中的一个模板类，用于管理互斥锁（ <code>std::mutex</code> ）的生命周期，提供更大的灵活性和功能，以确保在作用域结束时自动释放锁。 <code>std::unique_lock</code> 也是一种用于 RAII（资源获取即初始化）风格的锁管理。</p><p><code>std::unique_lock</code> 具有以下主要特点和用途：</p><ol><li><strong>自动加锁和解锁</strong>：当创建 <code>std::unique_lock</code> 对象时，它可以选择是否自动锁定关联的互斥锁，还可以在其作用域结束时自动解锁互斥锁。这提供了更大的灵活性，因为您可以<mark>手动控制锁定和解锁的时机</mark>。</li><li><strong>异常安全</strong>： <code>std::unique_lock</code> 提供了异常安全性，即使在作用域中抛出异常，也会在作用域结束时正确释放锁，从而防止资源泄漏。</li><li><strong>支持延迟锁定</strong>： <code>std::unique_lock</code> <mark>允许您在等待条件变量时解锁互斥锁</mark>，然后重新锁定互斥锁，以提高效率和减少锁的占用时间。</li><li><strong>手动锁定和解锁</strong>：您<mark>可以随时手动锁定和解锁互斥锁</mark>，以执行更复杂的操作。</li></ol><p>从上面这些特点看来，其实 <code>unique_lock</code> 和 <code>lock_guard</code> 颇有相似之处，都是 RAII 风格，都有相关的功能。但相比之下， <code>unique_lock</code> 有更大的灵活性，其可以控制加锁解锁的时机，可以手动加锁解锁，可以延迟锁定。二者的具体差异如下：</p><ol><li><strong>灵活性</strong>：<ul><li><code>std::lock_guard</code> 具有较低的灵活性，因为它只提供了自动加锁和解锁的功能。<mark>一旦创建，它不允许手动解锁或重新锁定互斥锁</mark>。这使得它非常适合那些不需要更复杂锁定操作的简单场景。</li><li><code>std::unique_lock</code> 具有更高的灵活性，因为它允许您手动锁定和解锁互斥锁。这意味着您可以选择何时锁定和解锁，还可以执行更复杂的操作，如延迟锁定和递归锁定。</li></ul></li><li><strong>锁定和解锁</strong>：<ul><li><code>std::lock_guard</code> 在构造时自动锁定互斥锁，并在作用域结束时自动解锁。没有手动解锁的选项。</li><li><code>std::unique_lock</code> <mark>在构造时可以选择是否锁定互斥锁</mark>（ <code>std::defer_lock</code> ），以及在作用域结束时是否自动解锁（ <code>std::adopt_lock</code> ）。您还可以<mark>随时手动解锁</mark>或重新锁定互斥锁（ <code>lock</code> 、 <code>unlock</code> ）。</li></ul></li><li><strong>延迟锁定和条件变量</strong>：<ul><li><code>std::unique_lock</code> 对于支持条件变量的操作非常有用，因为它<mark>可以在等待条件变量时解锁互斥锁</mark>（ <code>wait</code> ），然后重新锁定互斥锁。这允许线程在等待条件时不占用锁，提高了效率。</li><li><code>std::lock_guard</code> 不支持这种延迟锁定操作。</li></ul></li></ol><p>具体地，对于 <code>unique_lock</code> ，按照其默认的初始化方式，其在创建时自动加锁，离开作用域时自动解锁：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果需要控制使其在创建时不立即 / 自动加锁，则：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx, std::defer_lock)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果需要控制使其在离开作用域时不立即 / 自动解锁，则：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx, std::adopt_lock)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这表明在创建该 <code>unique_lock</code> 时 mtx 已经被上锁了，并且在其作用域结束时不要自动解锁。<p></p><p>参考链接：<br><span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL3RocmVhZC91bmlxdWVfbG9jay91bmlxdWVfbG9jaw==">unique_lock constructor</span><br><span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL3RocmVhZC9sb2NrX3RhZw==">lock_tag</span></p><h5 id="4-scoped_lock"><a class="anchor" href="#4-scoped_lock">#</a> 4、scoped_lock</h5><p>#CPP 新特性 #CPP17<br><code>std::scoped_lock</code> 是 C++17 标准引入的一个 RAII 风格的模板类，用于<mark>管理多个互斥锁的生命周期</mark>。它是 <code>std::lock</code> 的一种更安全和方便的替代品，用于在一个作用域内同时锁定多个互斥锁，以避免死锁和提供异常安全性。</p><p><code>std::scoped_lock</code> 具有以下主要特点和用途：</p><ol><li><strong>同时锁定多个互斥锁</strong>： <code>std::scoped_lock</code> 允许您在一个作用域内同时锁定多个互斥锁，而不需要手动编写多次锁定的代码。</li><li><strong>自动解锁</strong>：与 <code>std::unique_lock</code> 类似， <code>std::scoped_lock</code> 会在其作用域结束时自动解锁所有已锁定的互斥锁，无论是正常退出还是由于抛出异常而退出。</li><li><strong>避免死锁</strong>： <code>std::scoped_lock</code> 在锁定多个互斥锁时会采用死锁避免算法，以避免死锁。</li><li><strong>异常安全</strong>： <code>std::scoped_lock</code> 提供了异常安全性，确保即使在作用域中抛出异常，已锁定的互斥锁也会被正确释放。</li></ol><p><code>std::scoped_lock</code> 和 <code>std::lock_guard</code> 的主要差异在于前者能够管理多个互斥锁，其余都大同小异。<br>对于两者的差异，可参考：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDMwMTk1OTgvc3RkbG9jay1ndWFyZC1vci1zdGRzY29wZWQtbG9jaw==">scoped_lock vs lock_guard</span></p><blockquote><p><code>scoped_lock</code> 和 <code>lock_guard</code> 的区别？</p></blockquote><p>在 C++17 标准中， <code>std::scoped_lock</code> 和 <code>std::lock_guard</code> 都是用于管理互斥锁（mutex）的锁类型，它们确保在作用域结束时自动释放锁。然而，它们有一些不同之处，主要体现在它们的设计目的和功能上。</p><p><code>std::scoped_lock</code></p><ul><li><strong>功能</strong>: <code>std::scoped_lock</code> 主要用于同时锁定多个互斥锁。它提供了一个锁定多个互斥锁的安全机制，防止死锁的发生。</li><li><strong>特性</strong>：支持锁定多个互斥锁，并按照指定的顺序锁定，防止死锁。</li><li><strong>引入</strong>: C++17 标准引入。</li></ul><p><code>std::lock_guard</code></p><ul><li><strong>功能</strong>: <code>std::lock_guard</code> 用于在单个互斥锁上实现简单的 RAII（资源获取即初始化）风格的锁定。它在构造时锁定互斥锁，在析构时自动释放锁。</li><li><strong>特性</strong>：只能锁定一个互斥锁，适用于简单的互斥锁管理。</li><li><strong>引入</strong>: C++11 标准引入。</li></ul><p>具体区别</p><ol><li><strong>锁定多个互斥锁</strong>:</li></ol><ul><li><p><code>std::scoped_lock</code> 可以同时锁定多个互斥锁，防止死锁。例如：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::mutex m1, m2;</span><br><span class="line"><span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(m1, m2)</span></span>;</span><br></pre></td></tr></table></figure><p></p></li><li><p><code>std::lock_guard</code> 只能锁定一个互斥锁。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::mutex m;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br></pre></td></tr></table></figure><p></p></li></ul><ol start="2"><li><strong>用法简洁性</strong>:</li></ol><ul><li>对于单个互斥锁，两者用法几乎一样，但 <code>std::scoped_lock</code> 在 C++17 中更推荐，因为它的名称更具描述性。</li><li>对于多个互斥锁， <code>std::scoped_lock</code> 提供了更简洁的语法。</li></ul><p>示例代码对比</p><ol><li><p>使用 <code>std::scoped_lock</code> :<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="type">size_t</span> <span class="title">get_tasks_queued</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::scoped_lock <span class="title">tasks_lock</span><span class="params">(tasks_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tasks.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>使用 <code>std::lock_guard</code> :<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="type">size_t</span> <span class="title">get_tasks_queued</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::lock_guard&lt;std::mutex&gt; <span class="title">tasks_lock</span><span class="params">(tasks_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tasks.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol><p>在这个具体的例子中，锁定一个互斥锁时，两者的效果是相同的。选择使用哪一个更多的是风格和一致性的考虑。如果代码库已经在使用 <code>std::scoped_lock</code> 来锁定单个或多个互斥锁，那么继续使用 <code>std::scoped_lock</code> 可能更一致。</p><p><strong>结论</strong></p><ul><li><strong>单个互斥锁</strong>: <code>std::lock_guard</code> 和 <code>std::scoped_lock</code> 都可以使用。 <code>std::scoped_lock</code> 的名称在语义上可能更明确。</li><li><strong>多个互斥锁</strong>：使用 <code>std::scoped_lock</code> 。</li><li><strong>代码一致性</strong>：根据代码库的风格和惯例来选择。C++17 及以后的代码可能更倾向于使用 <code>std::scoped_lock</code> 。</li></ul><p>总的来说：<br>使用 <code>std::lock_guard</code> 如果需要在整个作用域中管理一个互斥锁<br>使用 <code>std::scoped_lock</code> 如果需要在整个作用域中管理多个互斥锁（明确多于一个）<br>使用 <code>std::unique_lock</code> 如果需要在作用域中解锁互斥锁（包括使用条件变量）</p><h5 id="5-atomic"><a class="anchor" href="#5-atomic">#</a> 5、atomic</h5><p><code>std::atomic</code> 是 C++ 标准库提供的一组类型和函数，用于支持原子操作。原子操作是一种多线程编程中的同步机制，确保共享数据的并发访问是安全的，避免数据竞争和并发问题。 <code>std::atomic</code> 提供了一些可以在多线程环境中进行原子操作的基本数据类型，如整数、布尔值等。</p><p><code>std::atomic</code> 具有以下特点：</p><ol><li><strong>原子性</strong>： <code>std::atomic</code> 操作是原子的，要么完全执行，要么不执行。这意味着它们不会被其他线程中断，也不会导致竞态条件。</li><li><strong>不需要互斥锁</strong>： <code>std::atomic</code> 操作通常不需要显式的互斥锁，因为它们是原子的。这有助于提高多线程程序的性能。</li><li><strong>内存顺序（Memory Order）</strong>： <code>std::atomic</code> 操作允许您指定内存顺序，以控制操作的顺序和可见性，以满足程序的需求。</li></ol><p>常见的 <code>std::atomic</code> 类型包括 <code>std::atomic&lt;int&gt;</code> , <code>std::atomic&lt;bool&gt;</code> , <code>std::atomic&lt;std::shared_ptr&lt;T&gt;&gt;</code> 等，您可以根据需要选择合适的类型。</p><p>在多线程语境下， <code>std::atomic</code> 的常见用法包括：</p><ol><li><strong>实现原子计数器</strong>： <code>std::atomic</code> 可用于实现线程安全的计数器，如统计某个事件发生的次数。</li><li><strong>管理共享标志位</strong>： <code>std::atomic&lt;bool&gt;</code> 常用于管理共享标志位，用于控制线程的启动、停止或某个状态的切换。</li><li><strong>无锁数据结构</strong>： <code>std::atomic</code> 用于创建无锁数据结构，如无锁队列、无锁堆栈，以提高多线程程序的性能。</li><li><strong>原子操作函数</strong>： <code>std::atomic</code> 类型提供了一系列原子操作函数，如 <code>store</code> 、 <code>load</code> 、 <code>exchange</code> 、 <code>compare_exchange</code> 等，用于执行各种原子操作。</li><li><strong>控制并发访问</strong>： <code>std::atomic</code> 可以用于确保多线程环境中的共享数据的一致性，以避免竞态条件。</li></ol><p>简单来说，对于<mark>简单的内置变量</mark>，可通过  <code>atomic</code>  来进行多线程操作而不用使用锁。</p><p>头文件：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br></pre></td></tr></table></figure><p></p><p>atomic 是个模板，其对于变量的初始化：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">isReady</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; sum;</span><br><span class="line">std::<span class="built_in">atomic_init</span>(&amp;sum, <span class="number">17</span>);</span><br></pre></td></tr></table></figure><p></p><p>变量取值：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = num.<span class="built_in">load</span>();</span><br></pre></td></tr></table></figure><p></p><p>变量设值：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isReady.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">num.<span class="built_in">store</span>(<span class="number">19</span>);</span><br></pre></td></tr></table></figure><p></p><p>TBD，更多细节，参考：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWR1Y2F0aXZlLmlvL2Fuc3dlcnMvd2hhdC1pcy1hdG9taWMtdHlwZS1pbi1jcHA=">https://www.educative.io/answers/what-is-atomic-type-in-cpp</span><br><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzE5NzgzMjQvd2hhdC1leGFjdGx5LWlzLXN0ZGF0b21pYw==">https://stackoverflow.com/questions/31978324/what-exactly-is-stdatomic</span>（回答 2）</p><h3 id="四-相关概念"><a class="anchor" href="#四-相关概念">#</a> 四、相关概念</h3><h5 id="1-虚假唤醒"><a class="anchor" href="#1-虚假唤醒">#</a> 1、虚假唤醒</h5><p>虚假唤醒（Spurious Wakeup）是多线程编程中一个重要的概念，指的是在没有收到明确的通知的情况下，等待中的线程会偶尔自发地从休眠状态醒来。这种情况可能发生在使用条件变量（ <code>std::condition_variable</code> ）等线程同步机制时。</p><p>虚假唤醒有以下关键特点和考虑事项：</p><ol><li><strong>无通知情况下醒来</strong>：在条件变量的等待期间，线程可能因为某些系统或实现细节而在没有任何明确通知的情况下醒来。这是一个与多线程编程相关的现象，可能是由操作系统、编译器或硬件的特定行为导致的。</li><li><strong>检查条件的必要性</strong>：虚假唤醒的发生意味着等待线程必须谨慎处理醒来的情况。因此，在等待条件满足时，线程应该总是在一个循环中检查条件，而不是假设条件一定已满足。</li><li><strong>条件互斥</strong>：通常，虚假唤醒会伴随互斥锁的使用。线程在等待前获取互斥锁，然后在等待期间释放它，以确保其他线程能够访问共享资源。虚假唤醒可能会导致等待线程在检查条件前重新获取互斥锁。</li><li><strong>实现相关</strong>：虚假唤醒的频率可能因操作系统或编译器的实现而异。有些操作系统 / 编译器可能更容易发生虚假唤醒，而其他可能较少发生。</li></ol><h5 id="2-概念辨析"><a class="anchor" href="#2-概念辨析">#</a> 2、概念辨析</h5><p>以下概念都与多线程编程和并发相关：</p><ol><li><strong>阻塞（Blocking）</strong>：<ul><li>阻塞是指线程暂停其执行，等待某种事件的发生，通常是等待某个条件的满足或资源的可用性。在阻塞状态下，线程不会占用 CPU 时间，直到条件满足或资源可用时才会继续执行。</li></ul></li><li><strong>休眠（Sleeping）</strong>：<ul><li>休眠是阻塞的一种形式，线程在休眠状态下会进入一种低功耗状态，以节省系统资源。通常，线程会在休眠一段时间后自动醒来，或者通过外部事件唤醒。</li></ul></li><li><strong>挂起（Suspending）</strong>：<ul><li>挂起是指将线程的执行暂停，使其暂时不可运行。这可以是手动挂起线程，也可以是由操作系统或调度程序执行。线程在挂起状态下不会占用 CPU 时间，需要显式恢复才能继续执行。</li></ul></li><li><strong>忙等待（Busy-Waiting）</strong>：<ul><li>忙等待是一种线程等待条件满足的方式，它通过不断检查条件的变化来等待，而不是进入休眠状态。忙等待会占用大量的 CPU 时间，通常不是一种高效的等待方式，应该避免在需要长时间等待的情况下使用。</li></ul></li><li><strong>自旋（Spinning）</strong>：<ul><li>自旋是忙等待的一种形式，线程在自旋状态下会重复执行某个操作，通常是检查条件是否满足。自旋通常用于需要极短等待时间的情况，以避免进入和退出休眠状态的开销。</li></ul></li></ol><p>这些概念在多线程编程中有不同的用途和场景。选择适当的等待方式取决于具体的需求和性能要求。通常，阻塞和休眠是较为高效的等待方式，而忙等待和自旋适用于某些特定的情况。挂起通常用于需要手动控制线程生命周期的情况。</p><h3 id="五-关于-wait-的一些实验"><a class="anchor" href="#五-关于-wait-的一些实验">#</a> 五、关于 wait 的一些实验</h3><p>对于带条件的 wait，有以下几个实验：</p><p>在下面这个实验中，我们让线程 A 先运行，在线程 B 还未执行 notify 之前，线程 A 就跳过了 wait 并打印相关信息。这里我们让 A 线程中的休眠时间尽可能短，使得一旦线程 B notify，线程 A 马上解除阻塞。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isGood = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>+<span class="number">1</span>==<span class="number">2</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lck, []()&#123; <span class="keyword">return</span> isGood; &#125;);</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ThreadA] after wait, ThreadA prints&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            isGood = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line">    &#125; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sleep long enough to make sure ThreadA runs first</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>+<span class="number">1</span>==<span class="number">2</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; _(mtx);</span><br><span class="line">            isGood = <span class="literal">true</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ThreadB] 1 do something in ThreadB&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[ThreadB] 2 before notify ThreadA&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[ThreadB] 3 after notify ThreadA&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面这个实验表明：当调用 <code>cv.wait(lck, []()&#123; return isGood; &#125;);</code> 时，如果条件满足，则不会阻塞，不需要被 notify 就能直接执行后续代码。<p></p><p>其实就是验证了前文所说的：</p><blockquote><p>当第一次调用 wait 时，如果条件为真，不会发生阻塞，不需要 notify 就能继续执行后续代码</p></blockquote><p>在下面这个实验中，我们去掉了线程 B 中的 notify 动作，只修改 isGood 但不通知。同时，我们更改了线程 A 的休眠时间，让其在第一次执行之后等待足够长的时间以确保线程 B 已经将 isGood 改为 true。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>+<span class="number">1</span>==<span class="number">2</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lck, []()&#123; <span class="keyword">return</span> isGood; &#125;);</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ThreadA] after wait, ThreadA prints&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            isGood = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">8</span>));</span><br><span class="line">    &#125; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sleep long enough to make sure ThreadA runs first</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>+<span class="number">1</span>==<span class="number">2</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; _(mtx);</span><br><span class="line">            isGood = <span class="literal">true</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ThreadB] 1 do something in ThreadB&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;[ThreadB] 2 before notify ThreadA&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="comment">// // cv.notify_one();</span></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;[ThreadB] 3 after notify ThreadA&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[ThreadB] 2 set isGood to true and dont notify&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面这个实验进一步证明：当我们调用带条件的 wait 时，首先会判断条件是否满足，如果满足，则根本不需要 notify 就能往下走。如果把上面线程 A 的休眠时间改成 50 ms，则会产生截然不同的结果：由于休眠时间很短，线程 A 第一次输出打印信息并将 isGood 改为 false 后，由于线程 B 还来不及更改 isGood 的值，线程 A 再次进入作用域中，此时判断 isGood 条件仍为 false，于是阻塞。后续即使线程 B 中更改了 isGood 的值为 true，但由于没有 notify 函数，无法唤醒，线程 A 将永远阻塞在 wait 函数上。<p></p><p>下面这个实验则是在同一个作用域中多次调用 wait，只要条件满足，不阻塞，不需要 notify。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>+<span class="number">1</span>==<span class="number">2</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lck, []()&#123; <span class="keyword">return</span> isGood; &#125;);</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ThreadA] after wait, ThreadA prints&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            isGood = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            isGood = <span class="literal">true</span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lck, []()&#123; <span class="keyword">return</span> isGood; &#125;);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ThreadA] after second wait, ThreadA prints&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            isGood = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line">    &#125; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sleep long enough to make sure ThreadA runs first</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>+<span class="number">1</span>==<span class="number">2</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; _(mtx);</span><br><span class="line">            isGood = <span class="literal">true</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ThreadB] 1 do something in ThreadB&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;[ThreadB] 2 before notify ThreadA&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="comment">// // cv.notify_one();</span></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;[ThreadB] 3 after notify ThreadA&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[ThreadB] 2 set isGood to true and dont notify&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在下面这个实验中，我们在线程 B 中并不修改条件使其为真，但却 notify，模拟虚假唤醒。于是显然，线程 A 仍然阻塞在 wait。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>+<span class="number">1</span>==<span class="number">2</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lck, []()&#123; <span class="keyword">return</span> isGood; &#125;);</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ThreadA] after wait, ThreadA prints&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            isGood = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line">    &#125; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sleep long enough to make sure ThreadA runs first</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>+<span class="number">1</span>==<span class="number">2</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; _(mtx);</span><br><span class="line">            <span class="comment">// isGood = true;</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ThreadB] 1 do something in ThreadB&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[ThreadB] 2 before notify ThreadA&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[ThreadB] 3 after notify ThreadA&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>综上，带条件的 wait 完全可以视作：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">stop_waiting</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">wait</span>(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>参考链接：<br><span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL3RocmVhZA==">C++ 多线程原语</span></p><p>the End.</p><hr><div class="tags"><a href="/tags/CPP%E6%96%B0%E7%89%B9%E6%80%A7/" rel="tag"><i class="ic i-tag"></i> CPP新特性</a> <a href="/tags/CPP17/" rel="tag"><i class="ic i-tag"></i> CPP17</a> <a href="/tags/CPP11/" rel="tag"><i class="ic i-tag"></i> CPP11</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-10-18 11:24:17" itemprop="dateModified" datetime="2024-10-18T11:24:17+08:00">2024-10-18</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝杯咖啡吧~</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Rick how 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Rick how 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Rick how <i class="ic i-at"><em>@</em></i>how</li><li class="link"><strong>本文链接：</strong> <a href="https://how2051.github.io/2024/10/12/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="C++ 多线程">https://how2051.github.io/2024/10/12/C-多线程/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/10/11/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;ooo.0x0.ooo&#x2F;2023&#x2F;12&#x2F;08&#x2F;OAE0e6.jpg" title="C++ 智能指针"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>C++ 智能指针</h3></a></div><div class="item right"><a href="/2024/10/12/C-%E8%B8%A9%E6%B0%B4%E6%B4%BC/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;ooo.0x0.ooo&#x2F;2023&#x2F;12&#x2F;08&#x2F;OAE0e6.jpg" title="C++ 踩水洼"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>C++ 踩水洼</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-intro"><span class="toc-number">1.</span> <span class="toc-text">一、Intro</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF"><span class="toc-number">2.</span> <span class="toc-text">二、常见场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-a-%E7%BA%BF%E7%A8%8B%E5%92%8C-b-%E7%BA%BF%E7%A8%8B%E8%BD%AE%E6%B5%81%E6%89%A7%E8%A1%8C%E4%BA%92%E4%B8%BA%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.0.1.</span> <span class="toc-text">1、A 线程和 B 线程轮流执行，互为条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-a-%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%90%8Eb-%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%A4%9A%E6%AC%A1%E8%BD%AE%E6%B5%81%E6%89%A7%E8%A1%8C"><span class="toc-number">2.0.2.</span> <span class="toc-text">2、A 线程执行一次后，B 线程执行多次，轮流执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-a-%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%A4%9A%E6%AC%A1%E5%90%8Eb-%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E8%BD%AE%E6%B5%81%E6%89%A7%E8%A1%8C"><span class="toc-number">2.0.3.</span> <span class="toc-text">3、A 线程执行多次后，B 线程执行一次，轮流执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-a-%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%A4%9A%E6%AC%A1%E5%90%8Eb-%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%A4%9A%E6%AC%A1%E8%BD%AE%E6%B5%81%E6%89%A7%E8%A1%8C"><span class="toc-number">2.0.4.</span> <span class="toc-text">4、A 线程执行多次后，B 线程执行多次，轮流执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-a-%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%88%B0%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E5%90%8E%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85-b-%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%88%B0%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E7%84%B6%E5%90%8E-a-%E7%BA%BF%E7%A8%8B%E5%86%8D%E6%89%A7%E8%A1%8C"><span class="toc-number">2.0.5.</span> <span class="toc-text">5、A 线程执行到某个节点后需要等待 B 线程执行到某个节点，然后 A 线程再执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-a-%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%88%B0%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E5%90%8E%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85-b-%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%88%B0%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E7%84%B6%E5%90%8E%E4%B8%80%E8%B5%B7%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C"><span class="toc-number">2.0.6.</span> <span class="toc-text">6、A 线程执行到某个节点后需要等待 B 线程执行到某个节点，然后一起继续执行</span></a></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">三、相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-stdcondition_variable"><span class="toc-number">3.0.1.</span> <span class="toc-text">1、std::condition_variable</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#astdcondition_variablewait"><span class="toc-number">3.0.1.1.</span> <span class="toc-text">a）std::condition_variable::wait</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#bstdcondition_variablewait_for"><span class="toc-number">3.0.1.2.</span> <span class="toc-text">b）std::condition_variable::wait_for</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#cstdcondition_variablenotify_one-and-notify_all"><span class="toc-number">3.0.1.3.</span> <span class="toc-text">c）std::condition_variable::notify_one and notify_all</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-lock_guard"><span class="toc-number">3.0.2.</span> <span class="toc-text">2、lock_guard</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-unique_lock"><span class="toc-number">3.0.3.</span> <span class="toc-text">3、unique_lock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-scoped_lock"><span class="toc-number">3.0.4.</span> <span class="toc-text">4、scoped_lock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-atomic"><span class="toc-number">3.0.5.</span> <span class="toc-text">5、atomic</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">4.</span> <span class="toc-text">四、相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92"><span class="toc-number">4.0.1.</span> <span class="toc-text">1、虚假唤醒</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90"><span class="toc-number">4.0.2.</span> <span class="toc-text">2、概念辨析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E5%85%B3%E4%BA%8E-wait-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E9%AA%8C"><span class="toc-number">5.</span> <span class="toc-text">五、关于 wait 的一些实验</span></a></li></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2024/10/11/C-17-%E6%96%B0%E7%89%B9%E6%80%A7/" rel="bookmark" title="C++17 新特性">C++17 新特性</a></li><li><a href="/2024/10/11/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" rel="bookmark" title="C++ 智能指针">C++ 智能指针</a></li><li class="active"><a href="/2024/10/12/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="bookmark" title="C++ 多线程">C++ 多线程</a></li><li><a href="/2024/10/12/C-%E8%B8%A9%E6%B0%B4%E6%B4%BC/" rel="bookmark" title="C++ 踩水洼">C++ 踩水洼</a></li><li><a href="/2024/10/12/C-%E9%A2%84%E5%88%B6%E8%8F%9C/" rel="bookmark" title="C++ 预制菜">C++ 预制菜</a></li><li><a href="/2024/10/12/C-%E5%BA%93%E5%87%BD%E6%95%B0/" rel="bookmark" title="C++ 库函数">C++ 库函数</a></li><li><a href="/2024/10/18/C-%E7%9A%84%E5%B8%B8%E9%87%8F/" rel="bookmark" title="C++ 的常量">C++ 的常量</a></li><li><a href="/2024/10/18/C-%E7%9A%84%E5%A4%9A%E6%80%81/" rel="bookmark" title="C++ 的多态">C++ 的多态</a></li><li><a href="/2024/10/18/C-%E7%9A%84%E7%BB%A7%E6%89%BF/" rel="bookmark" title="C++ 的继承">C++ 的继承</a></li><li><a href="/2024/10/18/C-%E7%9A%84%E6%B5%81/" rel="bookmark" title="C++ 的流">C++ 的流</a></li><li><a href="/2024/10/18/C-%E7%B1%BB%E4%B8%8E%E6%A8%A1%E6%9D%BF/" rel="bookmark" title="C++ 类与模板">C++ 类与模板</a></li><li><a href="/2024/10/18/C-%E4%BB%80%E9%94%A6/" rel="bookmark" title="C++ 什锦">C++ 什锦</a></li><li><a href="/2024/10/18/C-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/" rel="bookmark" title="C++ 文件读写">C++ 文件读写</a></li><li><a href="/2024/10/18/C-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/" rel="bookmark" title="C++ 异常机制">C++ 异常机制</a></li><li><a href="/2024/10/18/extern-C/" rel="bookmark" title="extern C">extern C</a></li><li><a href="/2024/10/18/lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="bookmark" title="lambda 表达式">lambda 表达式</a></li><li><a href="/2024/10/21/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/" rel="bookmark" title="可变参数模板">可变参数模板</a></li><li><a href="/2024/10/21/%E3%80%8AGoogle-C-Style-Guide%E3%80%8Bnote/" rel="bookmark" title="《Google C++ Style Guide》note">《Google C++ Style Guide》note</a></li><li><a href="/2024/10/22/%E7%B2%97%E8%AF%BB-BS-thread-pool-%E6%9C%AD%E8%AE%B0/" rel="bookmark" title="粗读 BS_thread_pool 札记">粗读 BS_thread_pool 札记</a></li><li><a href="/2024/10/22/thread/" rel="bookmark" title="thread">thread</a></li><li><a href="/2024/10/22/async/" rel="bookmark" title="async">async</a></li><li><a href="/2024/10/22/promise/" rel="bookmark" title="promise">promise</a></li><li><a href="/2024/10/22/future/" rel="bookmark" title="future">future</a></li><li><a href="/2024/10/22/packaged-task/" rel="bookmark" title="packaged_task">packaged_task</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Rick how" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Rick how</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">30</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">4</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hvdzIwNTE=" title="https:&#x2F;&#x2F;github.com&#x2F;how2051"><i class="ic i-github"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmNoZW5oYW9fcHVibGljQDE2My5jb20=" title="mailto:chenhao_public@163.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/10/11/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/10/12/C-%E8%B8%A9%E6%B0%B4%E6%B4%BC/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Rick how @ R1ck's Playground</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">286k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:20</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/10/12/C-多线程/",favicon:{show:"欢迎回来~",hide:"等你回来~"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->