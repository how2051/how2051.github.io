<!-- build time:Tue Oct 22 2024 16:52:16 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="how" href="https://how2051.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="how" href="https://how2051.github.io/atom.xml"><link rel="alternate" type="application/json" title="how" href="https://how2051.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="CPP新特性,CPP11"><link rel="canonical" href="https://how2051.github.io/2024/10/18/C-%E4%BB%80%E9%94%A6/"><title>C++ 什锦 - C++ - 编程 | R1ck's Playground = how</title><meta name="generator" content="Hexo 7.0.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C++ 什锦</h1><div class="meta"><span class="item" title="创建时间：2024-10-18 11:14:37"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-10-18T11:14:37+08:00">2024-10-18</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>33k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>30 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">R1ck's Playground</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="item" rel="index" title="分类于 编程"><span itemprop="name">编程</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%BC%96%E7%A8%8B/C/" itemprop="item" rel="index" title="分类于 C++"><span itemprop="name">C++</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://how2051.github.io/2024/10/18/C-%E4%BB%80%E9%94%A6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Rick how"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="how"></span><div class="body md" itemprop="articleBody"><h3 id="i-右值引用"><a class="anchor" href="#i-右值引用">#</a> i、右值引用</h3><h5 id="概述"><a class="anchor" href="#概述">#</a> 概述</h5><p>右值引用是 C++11 引入的一种新的引用类型，用于支持<strong>移动语义</strong>和<strong>完美转发</strong>。与传统的左值引用（左值引用）不同，右值引用绑定到<strong>临时对象</strong>、<strong>将要销毁的对象</strong>或者<strong>显式转换为右值引用的对象</strong>。右值引用的特点是可以接管资源，并实现高效的资源移动操作。</p><p>在 C++ 中，我们可以通过在类型名称前添加 <code>&amp;&amp;</code> 来声明右值引用。例如， <code>int&amp;&amp;</code> 表示一个右值引用类型的整数。</p><p>右值引用的一些关键概念包括：</p><ol><li>左值（Lvalue）：左值是指一个具有标识符的、可寻址的对象。它可以出现在赋值表达式的左边或右边，并且具有持久的状态。左值引用（左值的引用）可以绑定到左值。</li><li>右值（Rvalue）：右值是指一个临时的、无法寻址的对象。它通常是一个临时表达式的结果，如常量、临时对象、将要销毁的对象等。右值引用可以绑定到右值。</li><li>移动语义（Move Semantics）：移动语义是通过右值引用实现的一种特性，允许将资源（如堆内存）从一个对象移动到另一个对象，而不是进行复制。移动语义可以提高性能，避免不必要的内存拷贝和资源分配。</li><li>完美转发（Perfect Forwarding）：完美转发是指在函数模板中以原样传递参数，既不进行拷贝也不进行移动，保持其原始类型。通过使用右值引用和模板参数推导，可以实现完美转发，将参数传递给下游函数，保持参数的值类别（左值或右值）和常量性。</li></ol><p>右值引用的引入使得 C++ 语言能够更好地处理资源管理和移动语义，<mark>避免不必要的数据拷贝</mark>，提高程序的效率和性能。它在移动语义、完美转发、智能指针等方面发挥了重要的作用。</p><h5 id="移动语义"><a class="anchor" href="#移动语义">#</a> 移动语义</h5><p>当涉及到资源管理或对象传递时，<strong>移动语义</strong>和<strong>完美转发</strong>可以提供更高效的操作和灵活性。</p><p>移动语义： 移动语义允许将资源（如堆内存）从一个对象移动到另一个对象，而不是进行复制。这可以避免不必要的内存拷贝和资源分配，提高程序的效率。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">        <span class="comment">// 分配内存并复制字符串</span></span><br><span class="line">        <span class="type">size_t</span> length = <span class="built_in">strlen</span>(str);</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor: &quot;</span> &lt;&lt; m_data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// 直接接管资源</span></span><br><span class="line">        m_data = other.m_data;</span><br><span class="line">        other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move Constructor: &quot;</span> &lt;&lt; m_data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>; <span class="comment">// 调用构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">MyString <span class="title">str2</span><span class="params">(std::move(str1))</span></span>; <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    <span class="comment">// 此时str1不再拥有资源，而是被str2接管了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在上面的示例中，我们定义了一个简单的字符串类 <code>MyString</code> ，它包含了一个动态分配的字符数组。通过移动构造函数，我们可以直接将资源从一个对象移动到另一个对象，而不需要进行额外的内存拷贝。在 <code>main</code> 函数中，我们创建了 <code>str1</code> 和 <code>str2</code> 两个对象，通过 <code>std::move</code> 将 <code>str1</code> 的资源移动给了 <code>str2</code> 。这样，资源的所有权从 <code>str1</code> 转移到了 <code>str2</code> ，并在程序结束时正确释放。</p><h5 id="完美转发"><a class="anchor" href="#完美转发">#</a> 完美转发</h5><p><strong>完美转发允许以原样传递参数，既不进行拷贝也不进行移动，保持其原始类型。</strong> 通过使用<strong>右值引用</strong>和<strong>模板参数推导</strong>，可以实现完美转发，将参数传递给下游函数，保持参数的值类别和常量性。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processValue</span><span class="params">(<span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lvalue: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processValue</span><span class="params">(<span class="type">int</span>&amp;&amp; value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rvalue: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forwardValue</span><span class="params">(T&amp;&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">processValue</span>(std::forward&lt;T&gt;(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    forwardValue(x);          <span class="comment">// 传递左值，调用 processValue(int&amp;)</span></span><br><span class="line">    forwardValue(<span class="number">123</span>);        <span class="comment">// 传递右值，调用 processValue(int&amp;&amp;)</span></span><br><span class="line">    forwardValue(std::<span class="built_in">move</span>(x)); <span class="comment">// 传递右值引用，调用 processValue(int&amp;&amp;)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在上面的示例中，我们定义了两个重载的 <code>processValue</code> 函数，一个接受左值引用，另一个接受右值引用。然后，我们使用模板函数 <code>forwardValue</code> 来实现完美转发。在 <code>forwardValue</code> 函数中，我们使用 <code>std::forward</code> 来保持参数的值类别（左值或右值）和常量性，并将参数传递给下游函数 <code>processValue</code> 。通过完美转发，我们可以在保持原始参数类型的同时，将参数传递给适当的处理函数。</p><p>通过移动语义和完美转发，我们可以更高效地管理资源和实现灵活的参数传递。这些特性在处理大型对象、容器元素和函数传参时特别有用，可以避免不必要的拷贝和资源分配，提高程序的性能和效率。</p><h5 id="追问"><a class="anchor" href="#追问">#</a> 追问</h5><blockquote><p>1、移动构造函数中的 noexcept 有何作用，是否一定需要？</p></blockquote><p><code>noexcept</code> 在移动构造函数中的作用是指定该函数是否可能抛出异常。使用 <code>noexcept</code> 关键字可以提供编译器优化的机会，因为它使得在移动构造函数中执行更轻量级的操作，如移动资源的所有权，而无需进行异常处理。这样可以提高程序的性能。然而， <code>noexcept</code> 并不是必需的，你可以选择是否在移动构造函数中使用它，具体取决于你的需求。</p><blockquote><p>2、调用 <code>std::move</code> 后的变量是否不能够再次被使用？</p></blockquote><p>调用 <code>std::move</code> 后的变量仍然可以被使用，但是它的状态会发生变化。 <code>std::move</code> 将变量转换为右值引用，这意味着它可以被移动而不是复制。移动后的变量的状态通常是不确定的，<mark>你不应该对其进行操作或访问其值</mark>。它通常被用于将资源所有权转移给其他对象，或作为参数传递给接受右值引用的函数。在移动后，你可以重新赋值给它或销毁它。重要的是要记住，<mark> <code>std::move</code> 仅仅是改变了变量的类型，而不会对其值进行任何修改</mark>。</p><h3 id="i-c-内存分布"><a class="anchor" href="#i-c-内存分布">#</a> i、C++ 内存分布</h3><p>在 C++ 程序中，内存可以划分为以下几个主要区域：</p><ol><li>栈（Stack）：<ul><li>栈位于内存的较高地址部分。</li><li>栈用于存储函数的局部变量、函数参数、函数调用信息等。</li><li>栈的分配和释放是由编译器自动管理的，具有自动内存管理的特性。</li><li>栈的大小在程序运行时是固定的。</li></ul></li><li>堆（Heap）：<ul><li>堆位于内存的较低地址部分。</li><li>堆用于动态分配内存，由程序员手动管理。</li><li>堆的分配和释放需要使用特定的函数（如 <code>new</code> 和 <code>delete</code> 、 <code>malloc</code> 和 <code>free</code> 等）进行操作。</li><li>堆的大小在程序运行时可以动态变化。</li></ul></li><li>全局区（Global Area）：<ul><li>全局区也称为静态区或数据段。</li><li>全局区存储全局变量、静态变量和常量。</li><li>全局区在程序运行期间一直存在，直到程序结束。</li><li>全局区的大小在编译时确定。</li></ul></li><li>常量区（Constant Area）：<ul><li>常量区也称为文字常量区或只读数据区。</li><li>常量区存储字符串常量和其他常量数据。</li><li>常量区的数据是只读的，不能被修改。</li><li>常量区在程序运行期间一直存在，直到程序结束。</li></ul></li><li>代码区（Code Area）：<ul><li>代码区也称为文本区或只读代码区。</li><li>代码区存储程序的执行代码。</li><li>代码区的数据是只读的，不能被修改。</li><li>代码区在程序运行期间一直存在，直到程序结束。</li></ul></li></ol><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">|        栈 (Stack)      |</span><br><span class="line">|                       |</span><br><span class="line">|                       |</span><br><span class="line">|                       |</span><br><span class="line">+-----------------------+</span><br><span class="line">|        堆 (Heap)       |</span><br><span class="line">|                       |</span><br><span class="line">|                       |</span><br><span class="line">|                       |</span><br><span class="line">+-----------------------+</span><br><span class="line">|    全局区 (Global)     |</span><br><span class="line">|                       |</span><br><span class="line">|                       |</span><br><span class="line">|                       |</span><br><span class="line">+-----------------------+</span><br><span class="line">|    常量区 (Constant)   |</span><br><span class="line">|                       |</span><br><span class="line">|                       |</span><br><span class="line">|                       |</span><br><span class="line">+-----------------------+</span><br><span class="line">|    代码区 (Code)      |</span><br><span class="line">|                       |</span><br><span class="line">|                       |</span><br><span class="line">|                       |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure><p></p><h3 id="i-c内存模型"><a class="anchor" href="#i-c内存模型">#</a> i、C++ 内存模型</h3><h5 id="概述-2"><a class="anchor" href="#概述-2">#</a> 概述</h5><p>C++ 内存模型是描述 C++ 程序在执行过程中，内存访问和操作的规则和保证的规范。它定义了多线程环境下的原子性操作、内存顺序、可见性等行为，以确保多线程程序的正确性和可预测性。</p><p>下面是 C++ 内存模型中的几个重要概念：</p><ol><li>原子性（Atomicity）：原子操作是不可被中断的单个操作，要么完全执行，要么不执行。C++ 提供了原子操作库（std::atomic），用于在多线程环境下实现原子操作，保证对共享变量的读写操作的原子性。</li><li>内存顺序（Memory Order）：内存顺序规定了多个线程对共享变量的读写操作的顺序。C++ 提供了一组枚举类型（如 <code>std::memory_order_relaxed</code> 、 <code>std::memory_order_acquire</code> 、 <code>std::memory_order_release</code> 等），用于指定不同的内存顺序要求。</li><li>可见性（Visibility）：可见性指的是一个线程对共享变量的修改对其他线程是否可见。C++ 内存模型确保了原子操作的可见性，即一个原子操作对其他线程是立即可见的。</li><li>Happens-Before 关系：Happens-Before 关系是 C++ 内存模型中的一个重要概念，它用于描述不同操作之间的顺序关系。如果一个操作 A Happens-Before 于另一个操作 B，那么在多线程环境下，操作 A 的结果对操作 B 是可见的。Happens-Before 关系可以由同步操作（如互斥锁、原子操作等）和特定的内存顺序关系来建立。</li></ol><p>C++ 内存模型提供了一系列的规则和保证，以帮助程序员编写正确且具有可移植性的多线程程序。它规定了各种操作之间的可见性和顺序关系，并提供了原子操作和内存顺序的机制，使得程序在多线程环境下能够正确地进行内存访问和操作。</p><p>需要注意的是，C++ 内存模型并不是操作系统的内存管理模型，它更关注于程序在多线程环境下的内存访问规则和行为。对于底层的内存管理细节（如页面管理、缓存一致性等），C++ 内存模型通常依赖于操作系统和硬件的支持。</p><h5 id="内存顺序"><a class="anchor" href="#内存顺序">#</a> 内存顺序</h5><p>当多个线程并发地访问和修改共享变量时，内存顺序定义了这些操作之间的顺序关系。C++ 中的内存顺序通过枚举类型 <code>std::memory_order</code> 来指定。</p><ol><li><code>std::memory_order_relaxed</code> （松散顺序）： <code>std::memory_order_relaxed</code> 是最宽松的内存顺序，它不对任何内存操作进行顺序限制。对于使用 <code>std::memory_order_relaxed</code> 的操作，<mark>编译器和处理器可以对其进行重排序</mark>，且不会对其他线程产生任何顺序上的约束。</li><li><code>std::memory_order_acquire</code> （获取顺序）：稍后解释。</li><li><code>std::memory_order_release</code> （释放顺序）：稍后解释。</li></ol><p>当多个线程并发地读写共享变量时，使用 <code>std::memory_order_acquire</code> 和 <code>std::memory_order_release</code> 可以确保读写操作之间的顺序关系和可见性。</p><p><code>std::memory_order_acquire</code> 用于读操作，它具有以下特性：</p><ol><li>在使用 <code>std::memory_order_acquire</code> 进行读操作时，该读操作之前的所有读写操作都不会被放置在该读操作之后。这意味着，使用 <code>std::memory_order_acquire</code> 读取的值不会是之前的写操作的过期值。</li><li><code>std::memory_order_acquire</code> 会建立 Happens-Before 关系，使得该读操作之前的写操作对当前线程可见。这意味着，在使用 <code>std::memory_order_acquire</code> 进行读操作后，当前线程能够观察到在该读操作之前发生的写操作所引入的更改。</li><li><code>std::memory_order_acquire</code> 并不会限制该读操作之后的任何操作的顺序，其他线程可以继续并发地读写共享变量。<br>相比于 <code>std::memory_order_relaxed</code> ，使用 <code>std::memory_order_acquire</code> 可以提供更强的内存顺序保证，确保了读操作的顺序关系和可见性。</li></ol><p><code>std::memory_order_release</code> 用于写操作，它具有以下特性：</p><ol><li>在使用 <code>std::memory_order_release</code> 进行写操作时，该写操作之后的所有读写操作都不会被放置在该写操作之前。这意味着，使用 <code>std::memory_order_release</code> 写入的值不会影响之后的读写操作的顺序。</li><li><code>std::memory_order_release</code> 会建立 Happens-Before 关系，使得该写操作对其他线程的读操作可见。这意味着，在使用 <code>std::memory_order_release</code> 进行写操作后，其他线程能够观察到该写操作所引入的更改。</li><li><code>std::memory_order_release</code> 并不会限制该写操作之前的任何操作的顺序，其他线程可以继续并发地读写共享变量。</li></ol><p>通过使用 <code>std::memory_order_acquire</code> 和 <code>std::memory_order_release</code> ，可以在多线程环境下实现同步原语，例如互斥锁或读写锁。一个线程在写入共享变量之前，使用 <code>std::memory_order_release</code> 进行写操作，而另一个线程在读取共享变量之前，使用 <code>std::memory_order_acquire</code> 进行读操作。这样可以确保数据的一致性和可见性，防止数据竞争和不确定行为的发生。</p><p>需要注意的是， <code>std::memory_order_acquire</code> 和 <code>std::memory_order_release</code> 是成对使用的。当一个线程使用 <code>std::memory_order_release</code> 顺序进行写操作时，另一个线程使用 <code>std::memory_order_acquire</code> 顺序进行相应的读操作，以建立 Happens-Before 关系。单独使用这两个内存顺序是不够的，要实现正确的同步，需要遵循正确的使用模式和配对操作。</p><p>这里需要注意的是， <code>std::memory_order_acquire</code> 和 <code>std::memory_order_release</code> 是一对配套使用的内存顺序，用于实现同步原语，例如互斥锁、读写锁等。当一个线程使用 <code>std::memory_order_release</code> 顺序进行写操作时，另一个线程使用 <code>std::memory_order_acquire</code> 顺序进行相应的读操作，这样可以建立 Happens-Before 关系，确保数据的正确同步。</p><p><code>std::memory_order_acquire</code> 和 <code>std::memory_order_release</code> 的主要目的是确保读操作和写操作之间的顺序关系和可见性，并防止编译器和处理器对其进行重排优化。</p><p><mark>简单来说，为了确保同步，读用 <code>std::memory_order_acquire</code> ，写用 <code>std::memory_order_release</code> 即可。</mark></p><h3 id="i-全局变量与-static"><a class="anchor" href="#i-全局变量与-static">#</a> i、全局变量与 static</h3><h5 id="全局变量"><a class="anchor" href="#全局变量">#</a> 全局变量</h5><p>全局变量是定义在函数外部、整个源文件都可以访问的变量。它具有全局作用域和静态生存期，意味着它在整个程序的执行过程中都存在，并且可以被程序中的任何函数所使用。</p><p>全局变量的特点包括：</p><ol><li><strong>作用域</strong>：全局变量的作用域从定义处开始一直延伸到文件的末尾，整个源文件中的任何函数都可以访问这个变量。</li><li><strong>生命周期</strong>：全局变量在程序启动时分配内存，在程序结束时释放内存，因此它们的生命周期与整个程序的运行时间一样长。</li><li><strong>默认初始化</strong>：如果全局变量没有显式地初始化，那么它们会被默认初始化。</li><li><strong>存储位置</strong>：全局变量的存储位置通常位于静态存储区，在程序启动时分配，程序结束时释放。因此，全局变量的内存空间在整个程序的执行过程中都是固定的。</li><li><strong>可见性</strong>：全局变量在整个源文件中都是可见的，因此在不同的函数中可以共享数据。但是，过度使用全局变量会导致代码的可读性和维护性降低，因此应该尽量避免滥用全局变量，尤其是在大型项目中。</li></ol><p>全局变量的定义和声明一般放在源文件的顶部，在任何函数外部，使用关键字 <code>extern</code> 可以在其他源文件中引用全局变量。虽然全局变量具有方便性，但也容易引起命名冲突和程序设计的复杂性，因此在实际编程中需要谨慎使用。</p><h5 id="静态全局变量"><a class="anchor" href="#静态全局变量">#</a> 静态全局变量</h5><p>如果在全局变量的定义前加上 <code>static</code> 关键字进行修饰，则该变量就成为 <code>静态全局变量</code> 。<mark>静态全局变量的作用域仅限于当前文件，不能被其他文件访问。</mark></p><p>静态全局变量的特点包括：</p><ol><li><strong>作用域</strong>：与全局变量相同，静态全局变量的作用域也从定义处开始一直延伸到文件的末尾，但它<mark>只能在当前文件内部访问，其他文件无法访问。</mark></li><li><strong>生命周期</strong>：静态全局变量在程序启动时分配内存，在程序结束时释放内存，生命周期与整个程序的执行过程一样长。</li><li><strong>默认初始化</strong>：与全局变量相同，如果静态全局变量没有显式地初始化，它们会被默认初始化。</li><li><strong>存储位置</strong>：静态全局变量也存储在静态存储区，在程序启动时分配，程序结束时释放，内存空间在整个程序的执行过程中都是固定的。</li><li><strong>可见性</strong>：静态全局变量仅在当前文件内可见，不能被其他文件引用，因此不会引起命名冲突。</li></ol><p>由于静态全局变量的作用域受限于当前文件，因此它们通常被用于实现文件内部的全局状态或共享数据，同时避免了全局变量可能引发的命名冲突问题。</p><h5 id="全局变量与静态成员变量"><a class="anchor" href="#全局变量与静态成员变量">#</a> 全局变量与静态成员变量</h5><blockquote><p>假设我现在有一个 tool.cpp 和 tool.h 文件，其中我定义并实现了 Tool 这个类。<br>那么，对于某些变量，出于某些共享的需求，我既可以把它设置为全局变量，也可以把它设置成静态成员变量，这两种方式有什么区别？</p></blockquote><p>在 C++ 中，你可以通过将变量设置为全局变量或将其设置为类的静态成员变量来实现共享的需求，但这两种方式有一些区别：</p><ol><li><p><strong>作用域</strong>：</p><ul><li>全局变量的作用域是整个源文件，其他源文件也可以通过 extern 关键字来引用全局变量。（如果希望其只对 Tool 类可见，可添加 <code>static</code> 关键字使其局限在该 tool.cpp 文件中）</li><li>类的静态成员变量的作用域是整个类，可以通过 <code>类名::静态成员变量名</code> 来访问。</li></ul></li><li><p><strong>可见性</strong>：</p><ul><li>全局变量的可见性是整个源文件，其他源文件也可以通过 extern 关键字来引用全局变量。</li><li>类的静态成员变量的可见性是类的范围内，<mark>只有类的成员函数和友元函数可以直接访问静态成员变量。</mark></li></ul></li><li><p><strong>命名空间</strong>：</p><ul><li>全局变量属于全局命名空间，可能会导致命名冲突问题，特别是在大型项目中。</li><li>类的静态成员变量属于类的命名空间，可以通过类名限定来避免命名冲突。</li></ul></li><li><p><strong>初始化</strong>：</p><ul><li>全局变量在整个程序启动时会被初始化，如果没有显式地初始化，则会被默认初始化。</li><li>类的静态成员变量需要在类外部进行初始化，可以在类的定义外部进行初始化，也可以在类的实现文件中进行初始化。</li></ul></li></ol><p>综上所述，如果变量需要在多个源文件中共享，则通常选择全局变量；如果变量与类密切相关，并且只需要在类的范围内共享，则选择类的静态成员变量更为合适。<br>（比如两个源文件要进行线程同步，那么可选择使用全局变量的互斥锁、条件变量。）</p><h3 id="i-静态成员函数"><a class="anchor" href="#i-静态成员函数">#</a> i、静态成员函数</h3><p>在 C++ 中，静态成员函数是属于类而不是对象实例的函数。它们与类关联，而不是与类的具体实例关联。</p><h5 id="定义"><a class="anchor" href="#定义">#</a> 定义：</h5><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态成员函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以访问静态成员和其他静态成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonStaticFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以访问非静态成员和其他成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h5 id="调用"><a class="anchor" href="#调用">#</a> 调用：</h5><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass::<span class="built_in">staticFunction</span>(); <span class="comment">// 直接通过类名调用，而不需要创建类的实例</span></span><br></pre></td></tr></table></figure><p></p><h5 id="特点和用途"><a class="anchor" href="#特点和用途">#</a> 特点和用途：</h5><ul><li><p><strong>与类关联：</strong><br>静态成员函数与类关联，而不是与类的具体实例关联。因此，它们不访问任何特定对象的成员，<mark>也不能使用非静态成员变量或函数</mark>。</p></li><li><p><strong>无 this 指针：</strong><br>静态成员函数没有隐含的 <code>this</code> 指针，因为它们不与特定的对象实例相关联。这使得它们在不涉及实例数据的情况下执行更为灵活。（如果涉及，则需要进行绑定）</p></li><li><p><strong>访问静态成员：</strong><br>静态成员函数可以访问类的静态成员变量和其他静态成员函数。这使得它们适用于处理与类而不是与对象实例相关的操作。</p></li><li><p><strong>全局访问点：</strong><br>静态成员函数常用于提供一个全局访问点，例如工厂方法或全局配置设置。</p></li></ul><h3 id="i-野指针调用类的成员函数"><a class="anchor" href="#i-野指针调用类的成员函数">#</a> i、野指针调用类的成员函数</h3><p>在 C++ 中，当使用野指针（悬空指针）调用类的成员函数时，会发生未定义行为。野指针是指指向已释放的内存或者未初始化的内存的指针。使用野指针访问对象的成员函数可能导致程序崩溃或者产生其他不可预测的结果。</p><p>示例代码中的野指针就是将指针 pa 初始化为 nullptr，然后尝试通过它调用类 A 的成员函数 func ()。在这种情况下，由于 pa 指针指向了一个未定义的内存地址（nullptr），调用 func () 会导致未定义行为，这可能会导致程序崩溃。</p><p>在编写 C++ 代码时，应该始终确保指针的有效性，避免使用空指针和野指针。在使用指针之前，最好将其初始化为 nullptr，并在使用前进行有效性检查。可以使用条件语句或者智能指针来确保指针指向有效的对象，从而避免悬空指针的问题。</p><blockquote><p>追问：经过我的实践，野指针应该是仍然可以调用到类的成员函数的，只不过其结果是未定义的，是危险的。</p></blockquote><p>实际上，当野指针调用类的成员函数时，确实可以执行函数体内的代码，因为在编译时，编译器只需要知道函数的地址就可以调用它，不会检查指针是否为 nullptr 或者是否指向有效的对象。因此，代码在运行时仍然会执行类的成员函数，但是由于指针是悬空的，因此这样的行为是未定义的，可能会导致程序崩溃或者产生其他不可预测的结果。</p><p>虽然野指针调用类的成员函数可能不会立即导致程序崩溃，但这样的行为是非常危险的，可能会导致严重的后果，例如内存访问错误、数据损坏等。因此，应该始终避免使用空指针和野指针，并在使用指针之前进行有效性检查，以确保指针指向有效的对象。</p><blockquote><p>追问：但编译器是怎么知道成员函数的地址的呢？又或者说，类的成员函数存储在哪里？</p></blockquote><p>编译器在编译阶段会为类的成员函数生成代码，并将这些成员函数存储在程序的可执行文件中的代码段（text segment）中。成员函数的地址是由编译器在编译时决定的，通常在编译后的可执行文件中，成员函数会被编译成与类的对象无关的静态函数（static function），这意味着它们不依赖于任何特定的对象实例。</p><p>当调用类的成员函数时，实际上是通过类的对象（或类的指针 / 引用）来调用的，编译器会将对象的地址作为隐式的参数传递给成员函数，从而让成员函数知道自己是属于哪个对象的。在函数体内，成员函数可以通过 <code>this</code> 指针来访问类的成员变量和其他成员函数。</p><p>由于成员函数存储在代码段中，它们的地址在程序运行时是固定的。当通过类的对象（或指针 / 引用）调用成员函数时，编译器会在运行时使用正确的地址来调用相应的函数。</p><p>需要注意的是，对于虚函数（virtual function），编译器会通过虚函数表（vtable）来实现动态绑定，使得在运行时可以根据实际对象的类型来调用正确的虚函数。虚函数表是一个由编译器生成的数据结构，其中存储了每个虚函数的地址。这样，当通过指向基类的指针或引用调用虚函数时，会根据对象的实际类型来查找正确的虚函数地址。</p><h3 id="i-委托构造函数"><a class="anchor" href="#i-委托构造函数">#</a> i、委托构造函数</h3><p>#CPP 新特性 #CPP11<br>委托构造函数是 C++11 引入的一个特性，它允许一个构造函数调用同一个类中的另一个构造函数，从而避免代码重复。通过委托构造函数，可以在构造过程中重用已有的构造函数代码。</p><p>即，当在一个类中定义多个构造函数，并且其中一些构造函数有共同的初始化逻辑时，委托构造函数可以帮助你避免重复编写相同的初始化代码。</p><p>简单举例：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 假设我们在构造函数中都需要做一系列相同的初始化操作</span></span><br><span class="line">    <span class="comment">// 比如这里我们简单举例，我们需要计算 x + y 的值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Point</span>() : <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 默认构造函数</span></span><br><span class="line">        <span class="type">int</span> sum = x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> xCoord, <span class="type">int</span> yCoord) : <span class="built_in">x</span>(xCoord), <span class="built_in">y</span>(yCoord) &#123;</span><br><span class="line">        <span class="comment">// 带参数构造函数</span></span><br><span class="line">        <span class="type">int</span> sum = x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> value) : <span class="built_in">x</span>(value), <span class="built_in">y</span>(value) &#123;</span><br><span class="line">        <span class="comment">// 参数为相同值的构造函数</span></span><br><span class="line">        <span class="type">int</span> sum = x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>那么上面的代码就是会造成很多冗余，尤其是当 <code>int sum = x + y;</code> 所简化的代码实际上是很多复杂的初始化操作的时候。于是我们就可以用到委托构造函数：</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>() : <span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>) &#123;  <span class="comment">// 这里调用另一个构造函数</span></span><br><span class="line">        <span class="comment">// 默认构造函数委托给带参数构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> xCoord, <span class="type">int</span> yCoord) : <span class="built_in">x</span>(xCoord), <span class="built_in">y</span>(yCoord) &#123;</span><br><span class="line">        <span class="comment">// 带参数构造函数</span></span><br><span class="line">        <span class="type">int</span> sum = x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> value) : <span class="built_in">Point</span>(value, value) &#123;  <span class="comment">// 这里调用另一个构造函数</span></span><br><span class="line">        <span class="comment">// 参数为相同值的构造函数委托给带参数构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>如上所示，通过委托函数，不再需要每个构造函数都执行 <code>int sum = x + y;</code> 减少了代码的冗余.<p></p><p>委托构造函数指的是<mark>主动发起调用</mark>的那个构造函数，也就是在构造函数内部通过委托调用另一个构造函数来共享初始化逻辑。被委托调用的构造函数称为目标构造函数。</p><p>通过使用委托构造函数，我们避免了重复编写相同的初始化代码。当我们改变构造函数的初始化逻辑时，只需要修改一处，所有委托该逻辑的构造函数都会自动更新。</p><p>需要注意以下几点：</p><ul><li>委托构造函数的初始化列表中只能调用同一个类中的其他构造函数，而不能调用基类的构造函数或其他类的构造函数。</li><li>委托构造函数的参数列表必须与被调用构造函数的参数列表匹配。</li><li>委托构造函数<mark>只能在成员初始化列表中调用</mark>另一个构造函数，<mark>不能在函数体中调用</mark></li><li>委托构造函数不需要包含构造函数的实际初始化操作，因为它会调用被委托的构造函数来完成初始化。</li></ul><p>再举个例子：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">MyClass</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 委托给其他构造函数</span></span><br><span class="line">        <span class="comment">// 可以在委托构造函数中执行一些通用的初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">member</span>(value) &#123;</span><br><span class="line">        <span class="comment">// 实际构造函数，完成特定的初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> member;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;      <span class="comment">// 调用委托构造函数</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">42</span>)</span></span>;  <span class="comment">// 调用实际构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>委托构造函数的函数体中的代码先执行还是委托构造函数的初始化列表中的目标构造函数先执行？</p></blockquote><p>在委托构造函数中，委托构造函数的初始化列表中的<mark>目标构造函数会先执行</mark>，然后才会执行委托构造函数的函数体中的代码。</p><p>这是因为委托构造函数的目的是将初始化工作委托给另一个构造函数完成，因此首先会执行目标构造函数的初始化列表中的代码，以确保对象的成员变量得到正确的初始化。然后，委托构造函数的函数体中的代码会在目标构造函数初始化之后执行。</p><p>以下是一个示例来说明这个顺序：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">MyClass</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;委托构造函数的函数体中的代码&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">member</span>(value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;目标构造函数的初始化列表中的代码&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> member;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;  <span class="comment">// 输出顺序：目标构造函数 -&gt; 委托构造函数的函数体</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在上述示例中，对象 <code>obj</code> 的创建过程中，== 首先会执行目标构造函数的初始化列表中的代码，然后执行委托构造函数的函数体中的代码。== 这是因为目标构造函数负责实际的初始化操作，而委托构造函数负责调用目标构造函数并共享初始化逻辑.</p><p>总结一下，委托构造函数的好处是提高了代码的可维护性和可读性，避免了重复编写相同的初始化代码，同时确保所有构造函数都使用了一致的初始化逻辑。这对于类的构造函数重用和管理非常有帮助。</p><p>实际工程中遇到的委托构造函数的例子：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> [[nodiscard]] thread_pool</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">thread_pool</span>() : <span class="built_in">thread_pool</span>(<span class="number">0</span>, [] &#123;&#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_pool</span><span class="params">(<span class="type">const</span> <span class="type">concurrency_t</span> num_threads)</span> : thread_pool(num_threads, [] &#123;</span>&#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_pool</span><span class="params">(<span class="type">const</span> std::function&lt;<span class="type">void</span>()&gt;&amp; init_task)</span> : thread_pool(<span class="number">0</span>, init_task) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">thread_pool</span>(<span class="type">const</span> <span class="type">concurrency_t</span> num_threads, <span class="type">const</span> std::function&lt;<span class="built_in">void</span>()&gt;&amp; init_task) : <span class="built_in">thread_count</span>(<span class="built_in">determine_thread_count</span>(num_threads)), <span class="built_in">threads</span>(std::<span class="built_in">make_unique</span>&lt;std::thread[]&gt;(<span class="built_in">determine_thread_count</span>(num_threads)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">create_threads</span>(init_task);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="i-using-和-typedef-的区别"><a class="anchor" href="#i-using-和-typedef-的区别">#</a> i、using 和 typedef 的区别</h3><p>#CPP 新特性 #CPP11<br><code>using</code> 别名是 <code>C++11</code> 标准引入的特性，它提供了更多的灵活性和可读性。使用 <code>using</code> 别名可以轻松地为现有类型创建别名，甚至可以为模板类型创建别名。现代 <code>C++</code> 更倾向于使用 using，更加直观明了。</p><p><strong>使用 <code>typedef</code> 的方式：</strong><br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> MyInt; <span class="comment">// 创建 int 的别名 MyInt</span></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>&gt; IntVector; <span class="comment">// 创建 std::vector&lt;int&gt; 的别名 IntVector</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用 <code>using</code> 的方式：</strong><br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MyInt = <span class="type">int</span>; <span class="comment">// 创建 int 的别名 MyInt</span></span><br><span class="line"><span class="keyword">using</span> IntVector = std::vector&lt;<span class="type">int</span>&gt;; <span class="comment">// 创建 std::vector&lt;int&gt; 的别名 IntVector</span></span><br></pre></td></tr></table></figure><p></p><p><code>using</code> 别名有一些明显的优势：</p><ol><li>可读性更强： <code>using</code> 别名的语法更加自然，易于理解。它直观地表达了创建类型别名的意图。</li><li>支持模板别名： <code>using</code> 别名<mark>支持为模板类型创建别名</mark>，而 <code>typedef</code> 在处理模板类型时可能会显得复杂。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyVector = std::vector&lt;T&gt;; <span class="comment">// 为 std::vector&lt;T&gt; 创建一个别名 MyVector</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyVector&lt;<span class="type">int</span>&gt; numbers; <span class="comment">// 使用 MyVector 作为 std::vector&lt;int&gt; 的别名</span></span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">73</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125; std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>与 <code>auto</code> 关联性更强： <code>using</code> 别名与 C++11 中引入的 <code>auto</code> 关联性更强，使得在使用类型推断时更加便利。</li></ol><p>特别地，如果是对结构体 struct 的别名，两个关键字的语法分别如下：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">float</span> width;</span><br><span class="line">    <span class="type">float</span> height;</span><br><span class="line">&#125; Size;</span><br></pre></td></tr></table></figure><p></p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Point = <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Size = <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">float</span> width;</span><br><span class="line">    <span class="type">float</span> height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h3 id="i-cast-类型转换"><a class="anchor" href="#i-cast-类型转换">#</a> i、cast 类型转换</h3><p>在 C++ 中，类型转换（Type Casting）是一种将一个数据类型的值转换为另一个数据类型的过程。C++ 提供了几种不同类型的类型转换，可大致分为隐式转换和显式转换，显式转换又包含：C 风格转换、 <code>static_cast</code> 、 <code>dynamic_cast</code> 、 <code>const_cast</code> 、 <code>reinterpret_cast</code> 。</p><p>1. <code>static_cast</code></p><ul><li>用途： <code>static_cast</code> 主要用于执行静态类型转换，可以在合理范围内进行类型转换。它用于处理通常是安全的、定义良好的转换。</li><li>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> integer = <span class="number">42</span>;</span><br><span class="line"><span class="type">float</span> floatingPoint = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(integer);</span><br></pre></td></tr></table></figure></li></ul><p>2. <code>dynamic_cast</code></p><ul><li>用途： <code>dynamic_cast</code> 主要用于在继承层次结构中执行基类到派生类的安全转换。它在运行时进行类型检查，<mark>只有当对象实际上是目标类型的派生类时，才会执行转换</mark>。通常与多态相关。</li><li>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"></span><br><span class="line">Base* basePtr = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"><span class="keyword">if</span> (derivedPtr) &#123;</span><br><span class="line">    <span class="comment">// 转换成功，derivedPtr 指向 Derived 类型的对象</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 转换失败，basePtr 不是 Derived 类型的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>3. <code>const_cast</code></p><ul><li>用途： <code>const_cast</code> 用于去除变量的 <code>const</code> 修饰符，允许修改原本被视为只读的对象。它通常用于修复旧代码或在需要时更改数据的常量属性。</li><li>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> readOnlyValue = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp; readWriteReference = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(readOnlyValue);</span><br><span class="line">readWriteReference = <span class="number">100</span>; <span class="comment">// 合法，修改了原本的只读变量</span></span><br></pre></td></tr></table></figure></li></ul><p>4. <code>reinterpret_cast</code></p><ul><li>用途： <code>reinterpret_cast</code> 用于执行低级别的转换，通常用于处理指针和引用之间的转换。这是最不安全的类型转换，因此应谨慎使用。</li><li>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> integerValue = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>* intPointer = &amp;integerValue;</span><br><span class="line"><span class="type">double</span>* doublePointer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">double</span>*&gt;(intPointer);</span><br></pre></td></tr></table></figure></li></ul><h5 id="static_cast-和-dynamic_cast-的区别和联系"><a class="anchor" href="#static_cast-和-dynamic_cast-的区别和联系">#</a> static_cast 和 dynamic_cast 的区别和联系</h5><p><strong>区别</strong>：<br><code>static_cast</code> ：</p><ol><li><strong>静态类型转换</strong>： <code>static_cast</code> 是一种在编译时进行类型转换的操作。它对于已知的、合法的转换非常有用，如整数到浮点数、指针之间的类型转换等。</li><li><strong>非安全性</strong>： <code>static_cast</code> 不执行运行时类型检查，因此在进行类型转换时，开发者需要确保转换是安全的，否则可能导致未定义的行为。</li><li><strong>用途</strong>：主要用于基本的类型转换，如整数之间的转换、指针类型的转换，以及在继承层次结构中进行向上或向下的类型转换。</li></ol><p><code>dynamic_cast</code> ：</p><ol><li><strong>动态类型转换</strong>： <code>dynamic_cast</code> 是一种在运行时进行类型转换的操作，主要用于处理继承层次结构中的类型转换。</li><li><strong>安全性</strong>： <code>dynamic_cast</code> 执行运行时类型检查，确保只有当对象实际上是目标类型的派生类时，才会执行转换。如果类型不匹配，它返回 <code>nullptr</code> （对于指针类型）或抛出 <code>std::bad_cast</code> 异常（对于引用类型）。</li><li><strong>用途</strong>：主要用于处理多态性，以安全地进行基类到派生类的类型转换。它在运行时提供了类型检查，可用于确保只有正确类型的对象才会进行转换。</li></ol><p><strong>联系</strong>：</p><ol><li><code>static_cast</code> 和 <code>dynamic_cast</code> 都用于类型转换，但它们的用途和时机不同。 <code>static_cast</code> 主要用于<mark>基本类型</mark>和向上 / 向下的继承层次结构中，而 <code>dynamic_cast</code> 主要用于<mark>多态性继承</mark>中的安全类型转换。</li><li><code>static_cast</code> 是在编译时执行的，因此更快，但不提供类型检查。 <code>dynamic_cast</code> 是在运行时执行的，提供了类型检查，但可能更慢。</li><li>在多态性和继承的情况下，应优先选择 <code>dynamic_cast</code> 以确保类型安全。 <code>static_cast</code> 更适用于普通的类型转换，如整数之间的转换。</li><li><code>static_cast</code> 和 <code>dynamic_cast</code> 都需要开发者谨慎使用，以避免不安全的类型转换和潜在的错误。</li></ol><p>在编写代码时，应根据具体情况和安全性需求来选择使用哪种类型转换方式。如果不确定，最好选择更安全的 <code>dynamic_cast</code> 。</p><h3 id="i-c-内部链接"><a class="anchor" href="#i-c-内部链接">#</a> i、C++ 内部链接</h3><p>内部链接（internal linkage）是 C++ 语言中的一个概念，用于描述声明或定义的实体在编译单元内部可见，而在其他编译单元中不可见的特性。</p><p>具有内部链接的实体只能在其定义所在的编译单元（通常是一个源文件）内部访问，而无法在其他编译单元中进行访问。这样做的目的是将实体限制在特定的作用域内，从而提高代码的模块化性和封装性。</p><p>在 C++ 中，可以使用两种方式来实现内部链接：</p><ol><li><p>未命名命名空间（unnamed namespace）：通过将实体放置在未命名命名空间中，可以确保这些实体仅在当前编译单元中可见，而无法在其他编译单元中访问。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;  <span class="comment">// 未命名 namespace</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>static 关键字：将函数或变量声明为 static，可以使它们具有内部链接。这意味着它们只能在当前编译单元中访问，而不能在其他编译单元中使用。</p></li></ol><p>内部链接是 C++ 编程中常用的技术之一，用于控制实体的可见性和访问范围，有助于提高代码的可维护性和安全性。</p><h3 id="i-extern-关键字"><a class="anchor" href="#i-extern-关键字">#</a> i、extern 关键字</h3><p><code>extern</code> 是 C++ 中的一个关键字，用于说明变量或函数的链接性（linkage）和作用域（scope）。它可以用在不同的上下文中，通常用于以下两个方面：</p><p>1.<strong> 链接性（Linkage）：</strong><br><code>extern</code> 用于<mark>说明一个变量或函数是在其他文件中定义的</mark>，而不是当前文件中定义的。它告诉编译器在链接时在其他文件中查找这个变量或函数的定义。在 C++ 中，变量和函数默认情况下具有外部链接性，也就是可以在其他文件中使用。但如果你想明确地指定一个变量或函数为外部链接性，你可以使用 <code>extern</code> 关键字。例如：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个全局变量 x，该变量在其他文件中定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个函数 foo，该函数在其他文件中定义</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br>这些声明告诉编译器在链接时查找变量 <code>x</code> 和函数 <code>foo</code> 的定义。<p></p><p>特别地，我们会用到 <code>extern C</code> 来告诉编译器使用 C 语言的函数链接性。<br><code>extern &quot;C&quot;</code> 是一种用于修改函数链接性和名称修饰的用法，通常与 C 和 C++ 混合编程时使用。它有以下作用：</p><p>a. <strong>函数链接性：</strong><br>在 C++ 中，函数默认会被名称修饰（name-mangling），以便支持函数重载。这导致 C++ 函数的名称在目标文件中不再是原始的函数名。然而，C 语言不使用名称修饰，因此在 C 和 C++ 混合编程时，需要确保 C++ 函数能够与 C 函数进行链接。使用 <code>extern &quot;C&quot;</code> 可以告诉编译器使用 C 语言的函数链接性。<br>b. <strong>函数名称修饰：</strong><br>在 C++ 中，函数名称会根据参数的类型和个数进行修饰，以支持函数重载。而 C 语言不支持函数重载，因此函数名称不会被修饰。使用 <code>extern &quot;C&quot;</code> 可以防止 C++ 对函数名称进行修饰，使函数名与 C 语言一致。</p><p>下面是一个示例：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个C函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">c_function</span><span class="params">(<span class="type">int</span> arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpp_function</span><span class="params">(<span class="type">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在上面的示例中， <code>c_function</code> 声明使用了 <code>extern &quot;C&quot;</code> ，这表示它的链接性和名称修饰与 C 语言兼容。这样，C 和 C++ 代码可以正确链接并一起工作。<p></p><p>2.<strong> 作用域（Scope）：</strong><br><code>extern</code> 也可以用于指示一个变量或函数的作用域是全局的，即它可以在程序的任何地方访问。通常，全局变量和函数默认具有全局作用域，但 <code>extern</code> 可以用于强调这一点。例如：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明全局变量 y 具有全局作用域</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> y;</span><br></pre></td></tr></table></figure><br>这个声明表示变量 <code>y</code> 具有全局作用域，可以在整个程序中访问。<p></p><p>总之， <code>extern</code> 是一个用于说明变量或函数链接性和作用域的关键字，它在 C++ 中通常用于与其他文件共享变量或函数的定义。</p><h3 id="i-dlopen-dlsym-和-dlclose"><a class="anchor" href="#i-dlopen-dlsym-和-dlclose">#</a> i、dlopen、dlsym 和 dlclose</h3><p>通过  <code>dlopen()</code>  函数以指定模式加载指定的动态链接库，并返回一个句柄。</p><p><code>dlsym()</code>  可通过 <code>dlopen()</code>  返回的句柄来调用指定的函数。</p><p>通过  <code>dlclose()</code>  来卸载已加载的动态库。</p><p><strong>dlopen()</strong> 的函数原型：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>pathname 是动态库的路径。</p><p>mode 是打开方式，有多种，这里列举两个： <code>RTLD_LAZY</code>  执行延迟绑定。仅在执行引用它们的代码时解析符号。如果从未引用该符号，则永远不会解析它（只对函数引用执行延迟绑定。在加载共享对象时，对变量的引用总是立即绑定）。 <code>RTLD_NOW</code>  如果指定了此值，或者环境变量  <code>LD_BIND_NOW</code>  设置为非空字符串，则在  <code>dlopen()</code>  返回之前，将解析共享对象中的所有未定义符号。如果无法执行此操作，则会返回错误。</p><p>打开失败时返回 NULL，打开成功则返回该动态库的句柄。</p><p><strong>dlsym()</strong> 的函数原型：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">dlsym</span><span class="params">(<span class="type">void</span>* handle, <span class="type">const</span> <span class="type">char</span>* symbol)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>该函数的作用是根据动态链接库的操作句柄 (handle) 与符号 (symbol)，返回符号对应的地址。这里的符号既可以是函数名，也可以是变量名。于是我们通过这个函数，就可以获取动态库中的函数或变量的地址，就可以调用动态库中的相关函数。</p><p>该函数的返回值  <code>void*</code>  指向函数的地址，供调用使用。</p><p><strong>dlclose()</strong> 就没啥好说的了，卸载相应的动态库。</p><p>具体使用示例：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *handle = <span class="built_in">dlopen</span>(str.<span class="built_in">c_str</span>(), RTLD_LAZY);</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*so_config)</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line">so_config config_func = <span class="built_in">dynamic_cast</span>&lt;so_config&gt;(<span class="built_in">dlsym</span>(handle, <span class="string">&quot;Config&quot;</span>));</span><br><span class="line"><span class="built_in">config_func</span>(ptr_len, ptr_ptr);</span><br></pre></td></tr></table></figure><p></p><p><code>dlerror()</code> 是一个用于获取动态链接库错误信息的函数，通常在使用动态链接库时发生错误时调用。该函数位于 <code>&lt;dlfcn.h&gt;</code> 头文件中，是 POSIX 标准的一部分。</p><p>当调用动态链接库相关函数（如 <code>dlopen()</code> 、 <code>dlsym()</code> 、 <code>dlclose()</code> 等）失败时，系统会设置一个全局错误状态，并通过 <code>dlerror()</code> 函数返回错误信息。如果前一个动态链接库相关函数调用成功，那么 <code>dlerror()</code> 将返回 NULL。</p><p>可以通过如下方式来使用 <code>dlerror()</code> 函数：</p><ol><li>当一个动态链接库相关函数返回 NULL 时，首先调用 <code>dlerror()</code> 函数来确定是否有错误发生。</li><li>如果 <code>dlerror()</code> 返回非 NULL 指针，则表示有错误发生，可以通过返回的字符串来获取错误信息。</li><li>如果 <code>dlerror()</code> 返回 NULL，则表示前一个动态链接库相关函数调用成功，没有错误发生。</li></ol><p>通过这种方式，可以在动态链接库加载、符号查找等过程中及时捕获并处理错误，提高程序的健壮性和可靠性。</p><h3 id="i-error-预处理指令"><a class="anchor" href="#i-error-预处理指令">#</a> i、error 预处理指令</h3><p><code>#error</code> 是 C/C++ 预处理器的一条指令，用于在预处理阶段生成编译错误信息。当预处理器遇到 <code>#error</code> 指令时，它会输出指定的错误消息，并终止编译过程。这对于在编译时进行条件检查非常有用，例如版本检查、平台检查或配置检查。</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (BS_THREAD_POOL_TEST_VERSION_MAJOR != BS_THREAD_POOL_VERSION_MAJOR)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">error</span> The versions do not match. Aborting compilation.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p></p><h3 id="i-quiet_nan"><a class="anchor" href="#i-quiet_nan">#</a> i、quiet_NaN</h3><p><code>std::numeric_limits&lt;float&gt;::quiet_NaN()</code> 返回表示 “静默 NaN（Not a Number）” 的浮点数。<br>NaN 是 IEEE 浮点数标准中定义的特殊值，用于表示不是数字的结果，通常用于错误处理或特殊情况下的标记。</p><p>这个函数返回的值是一个 float 类型的静默 NaN，它的位表示是特殊的，用于标记不是数字的情况。它不会抛出异常，因为它只是返回一个特定的值，不涉及任何运算或转换。</p><p>示例代码：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 float 类型的 NaN</span></span><br><span class="line">    <span class="type">float</span> nan = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">quiet_NaN</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 NaN 是否等于自身</span></span><br><span class="line">    <span class="keyword">if</span> (nan != nan) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;nan is not equal to itself&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;nan is equal to itself&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在示例中，我们获取了 float 类型的 NaN，并检查它是否等于自身。<br><mark>由于 NaN 的特性，它与自身不相等</mark>，因此程序输出 &quot;nan is not equal to itself&quot;。</p><h5 id="nan-的打印"><a class="anchor" href="#nan-的打印">#</a> NaN 的打印</h5><p>NaN 值是一个特殊的浮点数，它在打印时通常会显示为 <code>&quot;nan&quot;</code> （不区分大小写）。<br>因此，使用 <code>std::cout</code> 打印 <code>std::numeric_limits&lt;float&gt;::quiet_NaN()</code> 将会输出 <code>&quot;nan&quot;</code> 。</p><p>示例代码：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> nan = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">quiet_NaN</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;NaN value: &quot;</span> &lt;&lt; nan &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出结果将会是：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN value: nan</span><br></pre></td></tr></table></figure><p></p><h3 id="i-unordered_mapunordered_set-存储自定义类型"><a class="anchor" href="#i-unordered_mapunordered_set-存储自定义类型">#</a> i、unordered_map/unordered_set 存储自定义类型</h3><p>在使用 <code>unordered_map</code> 或 <code>unordered_set</code> 存储自定义结构体时，需要注意以下几点：</p><ol><li><strong>哈希函数和相等比较函数</strong>:<br>默认情况下， <code>unordered_map</code> 和 <code>unordered_set</code> 需要对键值进行哈希计算和相等比较。对于内置类型，这些操作已经定义好了，但对于自定义结构体，需要提供这两个函数。</li><li><strong>哈希函数</strong>:<br>必须提供一个自定义的哈希函数来计算自定义结构体的哈希值。你可以通过定义一个结构体或者函数对象来实现，也可以使用 C++11 的 <code>std::hash</code> 模板特化。</li><li><strong>相等比较函数</strong>:<br>需要提供一个自定义的相等比较函数，以确保 <code>unordered_map</code> 或 <code>unordered_set</code> 能正确比较两个自定义结构体是否相等。可以通过重载 <code>operator==</code> 或者定义一个函数对象来实现。</li></ol><p>以下是一个具体的示例，展示了如何为 <code>testStruct</code> 定义哈希函数和相等比较函数，使其可以用于 <code>unordered_map</code> 和 <code>unordered_set</code> ：</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义自定义结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">testStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 operator==，以便在哈希容器中进行比较</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> testStruct&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a == other.a &amp;&amp; b == other.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义哈希函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">testStructHash</span> &#123;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> testStruct&amp; ts)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::<span class="type">size_t</span> h1 = std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(ts.a);</span><br><span class="line">        std::<span class="type">size_t</span> h2 = std::<span class="built_in">hash</span>&lt;<span class="type">float</span>&gt;()(ts.b);</span><br><span class="line">        <span class="comment">// 组合两个哈希值</span></span><br><span class="line">        <span class="keyword">return</span> h1 ^ (h2 &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于测试的 main 函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用自定义结构体作为键的 unordered_map</span></span><br><span class="line">    std::unordered_map&lt;testStruct, std::string, testStructHash&gt; umap;</span><br><span class="line">    testStruct ts1 = &#123;<span class="number">1</span>, <span class="number">1.1f</span>&#125;;</span><br><span class="line">    testStruct ts2 = &#123;<span class="number">2</span>, <span class="number">2.2f</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    umap[ts1] = <span class="string">&quot;test1&quot;</span>;</span><br><span class="line">    umap[ts2] = <span class="string">&quot;test2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : umap) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key: (&quot;</span> &lt;&lt; pair.first.a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pair.first.b &lt;&lt; <span class="string">&quot;), Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义结构体的 unordered_set</span></span><br><span class="line">    std::unordered_set&lt;testStruct, testStructHash&gt; uset;</span><br><span class="line">    uset.<span class="built_in">insert</span>(ts1);</span><br><span class="line">    uset.<span class="built_in">insert</span>(ts2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : uset) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element: (&quot;</span> &lt;&lt; elem.a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; elem.b &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这个示例中，我们做了以下几步：</p><ol><li><strong>定义 <code>testStruct</code> 并重载 <code>operator==</code> </strong>: 以便在哈希容器中进行结构体比较。</li><li><strong>定义 <code>testStructHash</code> 结构体</strong>：用于计算 <code>testStruct</code> 的哈希值。我们使用了 <code>std::hash</code> 对 <code>int</code> 和 <code>float</code> 类型进行哈希计算，并将它们组合起来。</li><li><strong>在 <code>main</code> 函数中测试</strong>：使用 <code>unordered_map</code> 和 <code>unordered_set</code> 存储和访问 <code>testStruct</code> 。</li></ol><p>这样， <code>testStruct</code> 就可以顺利地用于 <code>unordered_map</code> 和 <code>unordered_set</code> 中。</p><blockquote><p>为什么不使用 lambda 表达式来实现哈希，而是要采用结构体？<br>为什么说 lambda “可读性和扩展性相对较低”，请你具体举例说明？</p></blockquote><p>用 lambda 表达式定义哈希函数确实可以简洁地实现某些功能，但在某些情况下，其可读性和扩展性相对于结构体方式可能会稍显不足。下面具体举例说明其不足之处：</p><ul><li>可读性问题</li></ul><ol><li>代码量较多时可读性下降：<br>当哈希计算逻辑复杂时，lambda 表达式可能会变得难以阅读。例如：</li></ol><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> complexHash = [](<span class="type">const</span> testStruct&amp; ts) -&gt; std::<span class="type">size_t</span> &#123;</span><br><span class="line">    std::<span class="type">size_t</span> h1 = std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(ts.a);</span><br><span class="line">    std::<span class="type">size_t</span> h2 = std::<span class="built_in">hash</span>&lt;<span class="type">float</span>&gt;()(ts.b);</span><br><span class="line">    std::<span class="type">size_t</span> h3 = std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(ts.a + <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(ts.b * <span class="number">100</span>));</span><br><span class="line">    <span class="keyword">return</span> h1 ^ (h2 &lt;&lt; <span class="number">1</span>) ^ (h3 &lt;&lt; <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>相对于这种复杂的 lambda 表达式，使用结构体来封装会使逻辑更清晰：</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">testStructHash</span> &#123;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> testStruct&amp; ts)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::<span class="type">size_t</span> h1 = std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(ts.a);</span><br><span class="line">        std::<span class="type">size_t</span> h2 = std::<span class="built_in">hash</span>&lt;<span class="type">float</span>&gt;()(ts.b);</span><br><span class="line">        std::<span class="type">size_t</span> h3 = std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(ts.a + <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(ts.b * <span class="number">100</span>));</span><br><span class="line">        <span class="keyword">return</span> h1 ^ (h2 &lt;&lt; <span class="number">1</span>) ^ (h3 &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><ul><li>扩展性问题</li></ul><ol><li>不能直接存储状态：<br>lambda 表达式本身不太适合存储状态。如果哈希函数需要存储一些额外的数据，使用结构体会更方便。例如：</li></ol><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">testStructHashWithState</span> &#123;</span><br><span class="line">    <span class="type">int</span> someState;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">testStructHashWithState</span>(<span class="type">int</span> state) : <span class="built_in">someState</span>(state) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> testStruct&amp; ts)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::<span class="type">size_t</span> h1 = std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(ts.a);</span><br><span class="line">        std::<span class="type">size_t</span> h2 = std::<span class="built_in">hash</span>&lt;<span class="type">float</span>&gt;()(ts.b);</span><br><span class="line">        <span class="keyword">return</span> (h1 ^ (h2 &lt;&lt; <span class="number">1</span>)) + someState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>用 lambda 表达式存储状态则相对麻烦：</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> someState = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> hashFn = [someState](<span class="type">const</span> testStruct&amp; ts) -&gt; std::<span class="type">size_t</span> &#123;</span><br><span class="line">    std::<span class="type">size_t</span> h1 = std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(ts.a);</span><br><span class="line">    std::<span class="type">size_t</span> h2 = std::<span class="built_in">hash</span>&lt;<span class="type">float</span>&gt;()(ts.b);</span><br><span class="line">    <span class="keyword">return</span> (h1 ^ (h2 &lt;&lt; <span class="number">1</span>)) + someState;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unordered_map&lt;testStruct, std::string, <span class="title">decltype</span><span class="params">(hashFn)</span>&gt; <span class="title">umap</span><span class="params">(<span class="number">10</span>, hashFn)</span></span>;</span><br></pre></td></tr></table></figure><p></p><ul><li>模板特化的灵活性</li></ul><p>如果需要在模板特化中定义哈希函数，使用结构体会更自然。示例：</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;testStruct&gt; &#123;</span><br><span class="line">        <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> testStruct&amp; ts)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            std::<span class="type">size_t</span> h1 = std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(ts.a);</span><br><span class="line">            std::<span class="type">size_t</span> h2 = std::<span class="built_in">hash</span>&lt;<span class="type">float</span>&gt;()(ts.b);</span><br><span class="line">            <span class="keyword">return</span> h1 ^ (h2 &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;testStruct, std::string&gt; umap;</span><br></pre></td></tr></table></figure><p></p><ul><li>代码复用</li></ul><p>结构体的方式便于代码复用和维护。例如，如果哈希计算逻辑需要在多个地方使用，用结构体封装的哈希函数可以直接复用，而不用在每个地方都写一次 lambda 表达式：</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;testStruct, std::string, testStructHash&gt; umap1;</span><br><span class="line">std::unordered_set&lt;testStruct, testStructHash&gt; uset1;</span><br></pre></td></tr></table></figure><p></p><p>如果用 lambda 表达式，每个地方都需要定义一次：</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> hashFn = [](<span class="type">const</span> testStruct&amp; ts) -&gt; std::<span class="type">size_t</span> &#123;</span><br><span class="line">    std::<span class="type">size_t</span> h1 = std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(ts.a);</span><br><span class="line">    std::<span class="type">size_t</span> h2 = std::<span class="built_in">hash</span>&lt;<span class="type">float</span>&gt;()(ts.b);</span><br><span class="line">    <span class="keyword">return</span> h1 ^ (h2 &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unordered_map&lt;testStruct, std::string, <span class="title">decltype</span><span class="params">(hashFn)</span>&gt; <span class="title">umap1</span><span class="params">(<span class="number">10</span>, hashFn)</span></span>;</span><br><span class="line"><span class="function">std::unordered_set&lt;testStruct, <span class="title">decltype</span><span class="params">(hashFn)</span>&gt; <span class="title">uset1</span><span class="params">(<span class="number">10</span>, hashFn)</span></span>;</span><br></pre></td></tr></table></figure><p></p><ul><li>总结<br>尽管 lambda 表达式在简单情况下非常方便，但当涉及复杂逻辑、状态存储、代码复用以及模板特化时，结构体的方式更具优势。因此，综合考虑可读性和扩展性，结构体定义方式通常是更好的选择。</li></ul><blockquote><p>这里重载 <code>operator==</code> 的作用是什么，为什么不用重载大于 <code>&gt;</code> 或者小于 <code>&lt;</code> ?</p></blockquote><p>在 C++ 中， <code>operator==</code> 和 <code>operator!=</code> 通常用于相等性比较，而 <code>operator&lt;</code> 和 <code>operator&gt;</code> 等用于排序。对于 <code>std::unordered_map</code> 和 <code>std::unordered_set</code> 来说，使用哈希表实现，因此需要的是相等性比较而不是排序比较。</p><p><code>std::unordered_map</code> 和 <code>std::unordered_set</code> 使用哈希表来存储元素。当我们插入、查找或删除元素时，这些容器会先根据哈希值（由哈希函数计算得出）将元素分配到某个桶中，然后在桶内使用 <code>operator==</code> 来比较元素是否相等。因此，为了在这些容器中使用自定义类型 <code>testStruct</code> ，我们必须重载 <code>operator==</code> 以定义两个 <code>testStruct</code> 对象何时被认为是相等的。</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">testStruct</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> testStruct&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a == other.a &amp;&amp; b == other.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><ul><li>为什么不用 <code>operator&lt;</code> 或 <code>operator&gt;</code></li></ul><p><code>operator&lt;</code> 和 <code>operator&gt;</code> 主要用于排序比较，在需要排序功能的容器如 <code>std::map</code> 和 <code>std::set</code> 中会用到。<mark>这些容器是基于红黑树等平衡二叉树实现的，因此需要知道两个元素之间的顺序关系。</mark></p><p>但是， <code>std::unordered_map</code> 和 <code>std::unordered_set</code> 是<mark>基于哈希表实现的，哈希表不需要排序元素，只需要将元素正确地放入桶中并能正确地比较桶内的元素是否相等</mark>。因此，在这种情况下，重载 <code>operator&lt;</code> 或 <code>operator&gt;</code> 是没有意义的，哈希表并不会使用这些操作符。</p><ul><li>总结</li></ul><ol><li><strong><code>operator==</code> 的作用</strong>： <code>operator==</code> 用于定义两个 <code>testStruct</code> 对象何时被认为是相等的，这对于哈希表在桶内比较元素是必要的。</li><li><strong>不用 <code>operator&lt;</code> 或 <code>operator&gt;</code> </strong>： <code>std::unordered_map</code> 和 <code>std::unordered_set</code> 基于哈希表实现，不需要排序元素，因此不需要 <code>operator&lt;</code> 或 <code>operator&gt;</code> 。这些操作符主要用于排序容器如 <code>std::map</code> 和 <code>std::set</code> 。</li></ol><h5 id="标准示范"><a class="anchor" href="#标准示范">#</a> 标准示范</h5><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for unordered_map and unordered_set</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> MyStruct&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a == other.a &amp;&amp; b == other.b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for map and set</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> MyStruct&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; other.a &amp;&amp; b &lt; other.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for unordered_map and unordered_set</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyHash</span> &#123;</span><br><span class="line">    <span class="comment">// this should be double const</span></span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> MyStruct&amp; ms)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::<span class="type">size_t</span> h1 = std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(ms.a);</span><br><span class="line">        std::<span class="type">size_t</span> h2 = std::<span class="built_in">hash</span>&lt;<span class="type">float</span>&gt;()(ms.b);</span><br><span class="line">        <span class="keyword">return</span> h1 ^ (h2 &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;MyStruct, <span class="type">int</span>, MyHash&gt; um;</span><br><span class="line">    um.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    MyStruct aa;</span><br><span class="line">    MyStruct bb;</span><br><span class="line"></span><br><span class="line">    um[aa] = <span class="number">0</span>;</span><br><span class="line">    um[bb] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    std::unordered_set&lt;MyStruct, MyHash&gt; us;</span><br><span class="line"></span><br><span class="line">    us.<span class="built_in">insert</span>(aa);</span><br><span class="line">    us.<span class="built_in">insert</span>(bb);</span><br><span class="line"></span><br><span class="line">    std::set&lt;MyStruct&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(aa);</span><br><span class="line">    s.<span class="built_in">insert</span>(bb);</span><br><span class="line"></span><br><span class="line">    std::map&lt;MyStruct, <span class="type">int</span>&gt; m;</span><br><span class="line">    m[aa] = <span class="number">0</span>;</span><br><span class="line">    m[bb] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="i-stdunordered_map-的使用"><a class="anchor" href="#i-stdunordered_map-的使用">#</a> i、std::unordered_map 的使用</h3><p><code>unordered_map</code> 是 C++ 标准库中的一种关联容器，它提供了一种无序、基于键值对的数据存储结构，具有快速的查找、插入和删除操作。 <code>unordered_map</code> 基于 <code>哈希表</code> 实现，可以在平均情况下以接近 <code>O(1)</code> 的时间复杂度进行元素的查找、插入和删除。</p><p>下面是 <code>unordered_map</code> 的一些常见用法：</p><ol><li><p><strong>创建 unordered_map 对象</strong>：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"><span class="comment">// 创建一个键为int类型，值为std::string类型的unordered_map对象</span></span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>插入元素</strong>：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myMap[<span class="number">1</span>] = <span class="string">&quot;value1&quot;</span>; <span class="comment">// 插入键值对 &lt;1, &quot;value1&quot;&gt;</span></span><br><span class="line">myMap.<span class="built_in">insert</span>(&#123;<span class="number">2</span>, <span class="string">&quot;value2&quot;</span>&#125;); <span class="comment">// 使用insert方法插入键值对 &lt;2, &quot;value2&quot;&gt;</span></span><br></pre></td></tr></table></figure><br>注意，如果是用 insert 的话，需要构造一个 <code>std::pair</code> 的对象。<p></p></li><li><p><strong>访问元素</strong>：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string value = myMap[<span class="number">1</span>]; <span class="comment">// 访问键为1的值，如果键不存在，则会插入一个默认构造的值</span></span><br></pre></td></tr></table></figure><br>注意！！！这种方式是存在副作用的，即 “<mark>键不存在时创建默认值</mark>”。<br>如果我们需要通过 map 的 size 来决定代码的逻辑，则应该避免使用这种方式来访问元素，以免对 size 造成影响！<p></p></li></ol><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = myMap.<span class="built_in">find</span>(<span class="number">2</span>); <span class="comment">// 使用find方法查找键为2的元素</span></span><br><span class="line"><span class="keyword">if</span>(iter != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::string value = iter-&gt;second; <span class="comment">// 访问找到的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ol start="4"><li><p><strong>删除元素</strong>：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myMap.<span class="built_in">erase</span>(<span class="number">1</span>); <span class="comment">// 删除键为1的元素</span></span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>遍历 unordered_map</strong>：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>获取 unordered_map 的大小</strong>：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = myMap.<span class="built_in">size</span>(); <span class="comment">// 获取unordered_map中键值对的个数</span></span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>检查 unordered_map 是否为空</strong>：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isEmpty = myMap.<span class="built_in">empty</span>(); <span class="comment">// 判断unordered_map是否为空</span></span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>清空 unordered_map</strong>：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myMap.<span class="built_in">clear</span>(); <span class="comment">// 清空unordered_map中的所有元素</span></span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>使用自定义哈希函数</strong>：<br>如果 <code>unordered_map</code> 的键类型不是基本类型（如 <code>int</code> 、 <code>std::string</code> 等），或者需要自定义哈希函数，可以通过 <code>unordered_map</code> 的第三个模板参数指定自定义的哈希函数，例如：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyKey</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyKeyHash</span> &#123;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> MyKey&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(key.id) ^ (std::<span class="built_in">hash</span>&lt;std::string&gt;()(key.name) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;MyKey, <span class="type">int</span>, MyKeyHash&gt; myMap; <span class="comment">// 使用自定义的哈希函数</span></span><br></pre></td></tr></table></figure><p></p></li></ol><p><code>unordered_map</code> 提供了丰富的功能，可以用于各种数据存储和处理场景，是 C++ 中非常常用的数据结构之一。</p><hr><h3 id="i-实现一个二分查找算法"><a class="anchor" href="#i-实现一个二分查找算法">#</a> i、实现一个二分查找算法</h3><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义二分查找函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt;&amp; arr, <span class="type">const</span> T&amp; target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> high = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// 找到目标值，返回索引</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;  <span class="comment">// 目标值在右半部分，调整区间的下界</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;  <span class="comment">// 目标值在左半部分，调整区间的上界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 没有找到目标值，返回 -1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>&#125;;  <span class="comment">// 注意，二分法需要应用于已排序的数组</span></span><br><span class="line">    <span class="type">int</span> target = <span class="number">12</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="built_in">binarySearch</span>(arr, target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index != <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Target found at index &quot;</span> &lt;&lt; index &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Target not found in the array&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>另外，STL 其实有封装二分查找的库，所以其实调个 API 就能实现了。见：<a href="https://how2051.github.io/2024/10/12/C-%E5%BA%93%E5%87%BD%E6%95%B0/#i-binary_search">binary_search</a><p></p><h3 id="i-用-c-实现-strcpy-函数"><a class="anchor" href="#i-用-c-实现-strcpy-函数">#</a> i、用 C++ 实现 strcpy 函数</h3><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查指针是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(dest == <span class="literal">nullptr</span> || src == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制字符串内容直到遇到空字符 &#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span>(*src != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        *dest = *src;</span><br><span class="line">        dest++;</span><br><span class="line">        src++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在目标字符串末尾添加空字符 &#x27;\0&#x27;</span></span><br><span class="line">    *dest = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* source = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">20</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(destination, source);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Copied string: &quot;</span> &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在上述代码中，strcpy 函数接受两个参数， <code>dest</code> 表示目标字符串的指针， <code>src</code> 表示源字符串的指针。函数通过遍历源字符串的每个字符，逐个将其复制到目标字符串，直到遇到空字符 <code>\0</code> ，表示字符串的结束。最后，将目标字符串的末尾设置为空字符 <code>\0</code> ，以确保复制后的字符串正确终止。<p></p><h5 id="内存踩踏"><a class="anchor" href="#内存踩踏">#</a> 内存踩踏</h5><p>当源字符串指针（src）和目标字符串指针（dest）所指向的内存有重叠部分时，使用标准的 <code>strcpy</code> 函数或自定义的 <code>strcpy</code> 函数可能会导致意想不到的结果。</p><p>在 C++ 中，按照标准的行为， <code>strcpy</code> 函数不应该用于处理重叠内存区域的字符串复制。这是因为在重叠内存区域中，复制的操作可能会导致数据的不可预测的改变。</p><p>具体来说，如果在 <code>strcpy</code> 函数中源字符串和目标字符串的内存区域重叠，复制过程中的操作可能会覆盖尚未被复制的数据，导致数据损坏或不正确的复制结果。</p><p>为了处理重叠内存区域的字符串复制，可以使用 <code>memmove</code> 函数，它被设计为可以处理重叠内存区域的内存复制操作。 <code>memmove</code> 函数的实现可以通过使用指针操作来实现内存块的移动。下面是一个用 C++ 编写的简单 <code>memmove</code> 函数的示例：</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memmove</span><span class="params">(<span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查指针是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (dest == <span class="literal">nullptr</span> || src == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时缓冲区</span></span><br><span class="line">    <span class="type">char</span>* temp = <span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制源内存块到临时缓冲区</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* srcPtr = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(src);</span><br><span class="line">    <span class="type">char</span>* tempPtr = temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        *tempPtr++ = *srcPtr++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将临时缓冲区的内容复制到目标内存块</span></span><br><span class="line">    <span class="type">char</span>* destPtr = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(dest);</span><br><span class="line">    tempPtr = temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        *destPtr++ = *tempPtr++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放临时缓冲区</span></span><br><span class="line">    <span class="keyword">delete</span>[] temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> source[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before memmove: &quot;</span> &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memmove</span>(destination, source, <span class="built_in">sizeof</span>(source));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After memmove: &quot;</span> &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在上述代码中， <code>memmove</code> 函数接受三个参数：目标指针（ <code>dest</code> ）、源指针（ <code>src</code> ）和要复制的字节数（ <code>size</code> ）。函数首先创建一个临时缓冲区，然后将源内存块的内容复制到临时缓冲区，最后再将临时缓冲区的内容复制到目标内存块。</p><p>请注意，在实际编写代码时，需要考虑更多的边界条件和错误处理，以确保函数的正确性和安全性。此外，C++ 标准库也提供了 <code>std::memmove</code> 函数，它是一个更为优化和健壮的实现，建议在实际使用中使用标准库提供的函数。</p><p>可以在不使用额外临时缓冲区的情况下实现 <code>memmove</code> 函数。一种常见的方法是使用指针操作和适当的条件判断来处理重叠内存块的移动。</p><p>下面是一个不使用额外临时缓冲区的 <code>memmove</code> 函数的示例实现：</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memmove</span><span class="params">(<span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查指针是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(dest == <span class="literal">nullptr</span> || src == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* destPtr = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(dest);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* srcPtr = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断重叠情况</span></span><br><span class="line">    <span class="keyword">if</span>(srcPtr &lt; destPtr) &#123;</span><br><span class="line">        <span class="comment">// 从后往前复制</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i = size; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            destPtr[i - <span class="number">1</span>] = srcPtr[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从前往后复制</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            destPtr[i] = srcPtr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> source[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before memmove: &quot;</span> &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memmove</span>(destination, source, <span class="built_in">sizeof</span>(source));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After memmove: &quot;</span> &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在上述代码中， <code>memmove</code> 函数首先判断源内存块和目标内存块的位置关系。如果源指针在目标指针之前，则从后往前逐个复制数据；如果源指针在目标指针之后，则从前往后逐个复制数据。通过这种方式，可以确保正确处理重叠内存块的复制，而无需使用额外的临时缓冲区。</p><p>需要注意的是，这种实现方式在处理重叠内存块时可能需要更多的指针操作和条件判断，因此在性能上可能不如使用临时缓冲区的实现方式高效。在实际使用时，根据具体的情况选择适合的实现方式，权衡性能和内存使用的需求。</p><div class="tags"><a href="/tags/CPP%E6%96%B0%E7%89%B9%E6%80%A7/" rel="tag"><i class="ic i-tag"></i> CPP新特性</a> <a href="/tags/CPP11/" rel="tag"><i class="ic i-tag"></i> CPP11</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-10-22 11:03:58" itemprop="dateModified" datetime="2024-10-22T11:03:58+08:00">2024-10-22</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝杯咖啡吧~</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Rick how 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Rick how 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Rick how <i class="ic i-at"><em>@</em></i>how</li><li class="link"><strong>本文链接：</strong> <a href="https://how2051.github.io/2024/10/18/C-%E4%BB%80%E9%94%A6/" title="C++ 什锦">https://how2051.github.io/2024/10/18/C-什锦/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/10/18/C-%E7%B1%BB%E4%B8%8E%E6%A8%A1%E6%9D%BF/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;ooo.0x0.ooo&#x2F;2023&#x2F;12&#x2F;08&#x2F;OAE0e6.jpg" title="C++ 类与模板"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>C++ 类与模板</h3></a></div><div class="item right"><a href="/2024/10/18/C-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;ooo.0x0.ooo&#x2F;2023&#x2F;12&#x2F;08&#x2F;OAE0e6.jpg" title="C++ 文件读写"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>C++ 文件读写</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#i-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">i、右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.0.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">1.0.2.</span> <span class="toc-text">移动语义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">1.0.3.</span> <span class="toc-text">完美转发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE"><span class="toc-number">1.0.4.</span> <span class="toc-text">追问</span></a></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#i-c-%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="toc-number">2.</span> <span class="toc-text">i、C++ 内存分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-c%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">i、C++ 内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">3.0.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.0.2.</span> <span class="toc-text">内存顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E-static"><span class="toc-number">4.</span> <span class="toc-text">i、全局变量与 static</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">4.0.1.</span> <span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">4.0.2.</span> <span class="toc-text">静态全局变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">4.0.3.</span> <span class="toc-text">全局变量与静态成员变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">i、静态成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">5.0.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8"><span class="toc-number">5.0.2.</span> <span class="toc-text">调用：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%E5%92%8C%E7%94%A8%E9%80%94"><span class="toc-number">5.0.3.</span> <span class="toc-text">特点和用途：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-%E9%87%8E%E6%8C%87%E9%92%88%E8%B0%83%E7%94%A8%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">i、野指针调用类的成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">i、委托构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-using-%E5%92%8C-typedef-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.</span> <span class="toc-text">i、using 和 typedef 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-cast-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">9.</span> <span class="toc-text">i、cast 类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#static_cast-%E5%92%8C-dynamic_cast-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">9.0.1.</span> <span class="toc-text">static_cast 和 dynamic_cast 的区别和联系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-c-%E5%86%85%E9%83%A8%E9%93%BE%E6%8E%A5"><span class="toc-number">10.</span> <span class="toc-text">i、C++ 内部链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-extern-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">11.</span> <span class="toc-text">i、extern 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-dlopen-dlsym-%E5%92%8C-dlclose"><span class="toc-number">12.</span> <span class="toc-text">i、dlopen、dlsym 和 dlclose</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-error-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-number">13.</span> <span class="toc-text">i、error 预处理指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-quiet_nan"><span class="toc-number">14.</span> <span class="toc-text">i、quiet_NaN</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#nan-%E7%9A%84%E6%89%93%E5%8D%B0"><span class="toc-number">14.0.1.</span> <span class="toc-text">NaN 的打印</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-unordered_mapunordered_set-%E5%AD%98%E5%82%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">15.</span> <span class="toc-text">i、unordered_map&#x2F;unordered_set 存储自定义类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%A4%BA%E8%8C%83"><span class="toc-number">15.0.1.</span> <span class="toc-text">标准示范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-stdunordered_map-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">16.</span> <span class="toc-text">i、std::unordered_map 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">17.</span> <span class="toc-text">i、实现一个二分查找算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-%E7%94%A8-c-%E5%AE%9E%E7%8E%B0-strcpy-%E5%87%BD%E6%95%B0"><span class="toc-number">18.</span> <span class="toc-text">i、用 C++ 实现 strcpy 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%B8%A9%E8%B8%8F"><span class="toc-number">18.0.1.</span> <span class="toc-text">内存踩踏</span></a></li></ol></li></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2024/10/11/C-17-%E6%96%B0%E7%89%B9%E6%80%A7/" rel="bookmark" title="C++17 新特性">C++17 新特性</a></li><li><a href="/2024/10/11/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" rel="bookmark" title="C++ 智能指针">C++ 智能指针</a></li><li><a href="/2024/10/12/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="bookmark" title="C++ 多线程">C++ 多线程</a></li><li><a href="/2024/10/12/C-%E8%B8%A9%E6%B0%B4%E6%B4%BC/" rel="bookmark" title="C++ 踩水洼">C++ 踩水洼</a></li><li><a href="/2024/10/12/C-%E9%A2%84%E5%88%B6%E8%8F%9C/" rel="bookmark" title="C++ 预制菜">C++ 预制菜</a></li><li><a href="/2024/10/12/C-%E5%BA%93%E5%87%BD%E6%95%B0/" rel="bookmark" title="C++ 库函数">C++ 库函数</a></li><li><a href="/2024/10/18/C-%E7%9A%84%E5%B8%B8%E9%87%8F/" rel="bookmark" title="C++ 的常量">C++ 的常量</a></li><li><a href="/2024/10/18/C-%E7%9A%84%E5%A4%9A%E6%80%81/" rel="bookmark" title="C++ 的多态">C++ 的多态</a></li><li><a href="/2024/10/18/C-%E7%9A%84%E7%BB%A7%E6%89%BF/" rel="bookmark" title="C++ 的继承">C++ 的继承</a></li><li><a href="/2024/10/18/C-%E7%9A%84%E6%B5%81/" rel="bookmark" title="C++ 的流">C++ 的流</a></li><li><a href="/2024/10/18/C-%E7%B1%BB%E4%B8%8E%E6%A8%A1%E6%9D%BF/" rel="bookmark" title="C++ 类与模板">C++ 类与模板</a></li><li class="active"><a href="/2024/10/18/C-%E4%BB%80%E9%94%A6/" rel="bookmark" title="C++ 什锦">C++ 什锦</a></li><li><a href="/2024/10/18/C-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/" rel="bookmark" title="C++ 文件读写">C++ 文件读写</a></li><li><a href="/2024/10/18/C-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/" rel="bookmark" title="C++ 异常机制">C++ 异常机制</a></li><li><a href="/2024/10/18/extern-C/" rel="bookmark" title="extern C">extern C</a></li><li><a href="/2024/10/18/lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="bookmark" title="lambda 表达式">lambda 表达式</a></li><li><a href="/2024/10/21/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/" rel="bookmark" title="可变参数模板">可变参数模板</a></li><li><a href="/2024/10/21/%E3%80%8AGoogle-C-Style-Guide%E3%80%8Bnote/" rel="bookmark" title="《Google C++ Style Guide》note">《Google C++ Style Guide》note</a></li><li><a href="/2024/10/22/%E7%B2%97%E8%AF%BB-BS-thread-pool-%E6%9C%AD%E8%AE%B0/" rel="bookmark" title="粗读 BS_thread_pool 札记">粗读 BS_thread_pool 札记</a></li><li><a href="/2024/10/22/thread/" rel="bookmark" title="thread">thread</a></li><li><a href="/2024/10/22/async/" rel="bookmark" title="async">async</a></li><li><a href="/2024/10/22/promise/" rel="bookmark" title="promise">promise</a></li><li><a href="/2024/10/22/future/" rel="bookmark" title="future">future</a></li><li><a href="/2024/10/22/packaged-task/" rel="bookmark" title="packaged_task">packaged_task</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Rick how" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Rick how</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">25</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">3</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">3</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hvdzIwNTE=" title="https:&#x2F;&#x2F;github.com&#x2F;how2051"><i class="ic i-github"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmNoZW5oYW9fcHVibGljQDE2My5jb20=" title="mailto:chenhao_public@163.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/10/18/C-%E7%B1%BB%E4%B8%8E%E6%A8%A1%E6%9D%BF/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/10/18/C-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Rick how @ R1ck's Playground</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">211k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">3:12</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/10/18/C-什锦/",favicon:{show:"欢迎回来~",hide:"等你回来~"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->