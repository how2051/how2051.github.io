<!-- build time:Sun Nov 03 2024 09:38:05 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="how" href="https://how2051.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="how" href="https://how2051.github.io/atom.xml"><link rel="alternate" type="application/json" title="how" href="https://how2051.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="CPP新特性,CPP17,CPP11"><link rel="canonical" href="https://how2051.github.io/2024/10/22/%E7%B2%97%E8%AF%BB-BS-thread-pool-%E6%9C%AD%E8%AE%B0/"><title>粗读 BS_thread_pool 札记 - asynchronous - C++ - 编程 | R1ck's Playground = how</title><meta name="generator" content="Hexo 7.0.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">粗读 BS_thread_pool 札记</h1><div class="meta"><span class="item" title="创建时间：2024-10-22 15:04:25"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-10-22T15:04:25+08:00">2024-10-22</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>25k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>22 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">R1ck's Playground</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="item" rel="index" title="分类于 编程"><span itemprop="name">编程</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%BC%96%E7%A8%8B/C/" itemprop="item" rel="index" title="分类于 C++"><span itemprop="name">C++</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%BC%96%E7%A8%8B/C/asynchronous/" itemprop="item" rel="index" title="分类于 asynchronous"><span itemprop="name">asynchronous</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://how2051.github.io/2024/10/22/%E7%B2%97%E8%AF%BB-BS-thread-pool-%E6%9C%AD%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Rick how"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="how"></span><div class="body md" itemprop="articleBody"><p>本文记录了阅读 <code>BS_thread_pool</code> 源码时的一些知识点，最好结合源码一起食用。<br><code>BS_thread_pool</code> 是 github 一个开源的线程池，源码地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JzaG9zaGFueS90aHJlYWQtcG9vbA==">thread-pool</span></p><h3 id="i-invoke_result_t"><a class="anchor" href="#i-invoke_result_t">#</a> i、invoke_result_t</h3><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">concurrency_t</span> = std::<span class="type">invoke_result_t</span>&lt;<span class="keyword">decltype</span>(std::thread::hardware_concurrency)&gt;;</span><br></pre></td></tr></table></figure><p></p><p>这行代码定义了一个别名 <code>concurrency_t</code> ，该别名代表 <code>std::thread::hardware_concurrency</code> 函数的返回类型。以下是对这行代码的详细解释：</p><p>分解解释</p><ol><li><p><strong><code>std::thread::hardware_concurrency</code> </strong>:</p><ul><li><code>std::thread::hardware_concurrency</code> 是一个静态成员函数，用于返回系统中可用并发线程的数量。该函数的返回类型通常是 <code>unsigned int</code> 。</li></ul></li><li><p><strong><code>decltype(std::thread::hardware_concurrency)</code> </strong>:</p><ul><li><code>decltype</code> 关键字用于查询表达式的类型。 <code>decltype(std::thread::hardware_concurrency)</code> 返回 <code>std::thread::hardware_concurrency</code> 函数的类型。</li><li>因为 <code>std::thread::hardware_concurrency</code> 是一个不接受任何参数的函数，所以 <code>decltype(std::thread::hardware_concurrency)</code> 返回的是一个函数类型（不是返回值类型，而是函数本身的类型）。</li></ul></li><li><p><strong><code>std::invoke_result_t&lt;...&gt;</code> </strong>:</p><ul><li><code>std::invoke_result_t</code> 是一个类型别名模板，用于获取调用给定可调用对象的结果类型。在这种情况下， <code>std::invoke_result_t&lt;decltype(std::thread::hardware_concurrency)&gt;</code> 表示调用 <code>std::thread::hardware_concurrency</code> 函数的结果类型。</li><li>换句话说， <code>std::invoke_result_t&lt;decltype(std::thread::hardware_concurrency)&gt;</code> 的作用是确定 <code>std::thread::hardware_concurrency()</code> 调用的返回类型。</li></ul></li></ol><p>组合解释</p><p>通过组合这些部分，整行代码的作用如下：</p><ul><li><code>decltype(std::thread::hardware_concurrency)</code> ：获取 <code>std::thread::hardware_concurrency</code> 函数的类型。</li><li><code>std::invoke_result_t&lt;decltype(std::thread::hardware_concurrency)&gt;</code> ：获取调用 <code>std::thread::hardware_concurrency()</code> 函数的返回类型。</li><li><code>using concurrency_t = std::invoke_result_t&lt;decltype(std::thread::hardware_concurrency)&gt;</code> ：定义一个别名 <code>concurrency_t</code> ，该别名代表 <code>std::thread::hardware_concurrency()</code> 的返回类型。</li></ul><p>代码效果</p><p>这个别名的实际效果是为 <code>std::thread::hardware_concurrency</code> 的返回类型提供一个简短的名称。由于 <code>std::thread::hardware_concurrency</code> 通常返回 <code>unsigned int</code> ，所以在大多数情况下， <code>concurrency_t</code> 就是 <code>unsigned int</code> 。</p><h3 id="i-nodiscard-class"><a class="anchor" href="#i-nodiscard-class">#</a> i、nodiscard class</h3><blockquote><p>在一个类的定义中，直接在 class 后面加 nodiscard 是什么作用？<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> [[nodiscard]] thread_pool</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><p>在 C++17 及其后的标准中， <code>[[nodiscard]]</code> 属性（attribute）被引入，用于指示特定函数或返回类型的<mark>结果不应被忽略</mark>。<mark>当应用于类时，它会要求所有返回该类类型的对象必须被使用</mark>。如果忽略了这样的返回值，编译器会生成一个警告。这对于提示程序员注意某些操作的结果是非常有用的，避免忽略可能的重要结果。</p><p>当 <code>[[nodiscard]]</code> 应用于一个类时，如果一个函数返回该类的对象并且调用者忽略了这个返回值，编译器将会发出一个警告。例如：</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread_pool <span class="title">create_thread_pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">thread_pool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">create_thread_pool</span>(); <span class="comment">// 这里会产生警告，因为返回的 thread_pool 对象被忽略了</span></span><br><span class="line">    <span class="keyword">auto</span> pool = <span class="built_in">create_thread_pool</span>(); <span class="comment">// 这里不会产生警告，因为返回的对象被使用了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这个例子中， <code>create_thread_pool</code> 函数返回一个 <code>thread_pool</code> 对象。<br>如果调用 <code>create_thread_pool</code> 时忽略了其返回值，编译器会生成一个警告，提示你可能忘记处理这个对象。</p><p>目的和优点</p><ol><li><strong>防止资源泄漏</strong>：对于表示资源管理的类，如线程池、文件句柄或智能指针，忽略返回值可能导致资源未正确管理。 <code>[[nodiscard]]</code> 可以提醒程序员必须处理这些对象。</li><li><strong>强制检查操作结果</strong>：有些操作可能失败，返回一个错误对象或状态对象。如果忽略了这些返回值，程序可能无法正确处理错误情况。</li><li><strong>提高代码安全性</strong>：通过强制检查返回值，可以减少因忽略重要操作结果而引入的潜在错误。</li></ol><p>具体应用场景</p><p>使用 <code>[[nodiscard]]</code> 属性的典型场景包括但不限于：</p><ol><li><strong>资源管理类</strong>：如线程池、文件操作类、网络连接类等。</li><li><strong>错误处理类</strong>：如表示错误状态或异常信息的类。</li><li><strong>智能指针</strong>：如自定义的智能指针实现。</li></ol><p>nodiscard 是一种属性说明符，在 <a href="https://how2051.github.io/2024/10/11/C-17-%E6%96%B0%E7%89%B9%E6%80%A7/#5-%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E%E7%AC%A6">属性说明符</a> 中还介绍了其他说明符。</p><h3 id="i-委托构造函数"><a class="anchor" href="#i-委托构造函数">#</a> i、委托构造函数</h3><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> [[nodiscard]] thread_pool</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">thread_pool</span>() : <span class="built_in">thread_pool</span>(<span class="number">0</span>, [] &#123;&#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_pool</span><span class="params">(<span class="type">const</span> <span class="type">concurrency_t</span> num_threads)</span> : thread_pool(num_threads, [] &#123;</span>&#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_pool</span><span class="params">(<span class="type">const</span> std::function&lt;<span class="type">void</span>()&gt;&amp; init_task)</span> : thread_pool(<span class="number">0</span>, init_task) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">thread_pool</span>(<span class="type">const</span> <span class="type">concurrency_t</span> num_threads, <span class="type">const</span> std::function&lt;<span class="built_in">void</span>()&gt;&amp; init_task) : <span class="built_in">thread_count</span>(<span class="built_in">determine_thread_count</span>(num_threads)), <span class="built_in">threads</span>(std::<span class="built_in">make_unique</span>&lt;std::thread[]&gt;(<span class="built_in">determine_thread_count</span>(num_threads)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">create_threads</span>(init_task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在 C++ 中，构造函数可以调用其他构造函数来初始化对象。这种技术被称为 “构造函数委托”（constructor delegation），可以简化构造函数的实现，避免重复代码。</p><ol><li>默认构造函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">thread_pool</span>() : <span class="built_in">thread_pool</span>(<span class="number">0</span>, [] &#123;&#125;) &#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个默认构造函数实际上是委托给另一个构造函数 <code>thread_pool(const concurrency_t num_threads, const std::function&lt;void()&gt;&amp; init_task)</code> ，它传递了两个参数： <code>0</code> 和 <code>[] &#123;&#125;</code> 。这里的 <code>0</code> 表示使用默认的线程数量， <code>[] &#123;&#125;</code> 是一个空的 lambda 函数，表示没有初始化任务。</p><ol start="2"><li>带线程数的构造函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread_pool</span><span class="params">(<span class="type">const</span> <span class="type">concurrency_t</span> num_threads)</span> : thread_pool(num_threads, [] &#123;</span>&#125;) &#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个构造函数接收一个参数 <code>num_threads</code> ，表示线程池的线程数量。它委托给另一个构造函数，传递 <code>num_threads</code> 和一个空的 lambda 函数 <code>[] &#123;&#125;</code> ，表示没有初始化任务。</p><ol start="3"><li>带初始化任务的构造函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread_pool</span><span class="params">(<span class="type">const</span> std::function&lt;<span class="type">void</span>()&gt;&amp; init_task)</span> : thread_pool(<span class="number">0</span>, init_task) &#123;</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个构造函数接收一个参数 <code>init_task</code> ，表示初始化任务。它委托给另一个构造函数，传递 <code>0</code> 和 <code>init_task</code> ， <code>0</code> 表示使用默认的线程数量。</p><ol start="4"><li>主构造函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">thread_pool</span>(<span class="type">const</span> <span class="type">concurrency_t</span> num_threads, <span class="type">const</span> std::function&lt;<span class="built_in">void</span>()&gt;&amp; init_task)</span><br><span class="line">    : <span class="built_in">thread_count</span>(<span class="built_in">determine_thread_count</span>(num_threads)), </span><br><span class="line">      <span class="built_in">threads</span>(std::<span class="built_in">make_unique</span>&lt;std::thread[]&gt;(<span class="built_in">determine_thread_count</span>(num_threads)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">create_threads</span>(init_task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个构造函数接收两个参数： <code>num_threads</code> 和 <code>init_task</code> 。它初始化 <code>thread_count</code> 和 <code>threads</code> ，然后调用 <code>create_threads(init_task)</code> 来创建线程，并执行初始化任务。</p><p>通过构造函数委托，你可以避免在每个构造函数中重复代码。每个构造函数只需要提供必要的参数，并将其委托给主构造函数进行实际的初始化。这使得代码更加简洁和易于维护。</p><p>关于委托构造函数的更多信息，可参考：<a href="https://how2051.github.io/2024/10/18/C-%E4%BB%80%E9%94%A6/#i-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">委托构造函数</a></p><h3 id="i-explicit"><a class="anchor" href="#i-explicit">#</a> i、explicit</h3><blockquote><p>追问：为什么这里的其中两个构造函数前面加了 explicit？</p></blockquote><p>在 C++ 中， <code>explicit</code> 关键字用于防止构造函数和转换运算符在某些情况下被隐式调用，从而避免意外的类型转换或构造函数调用。使用 <code>explicit</code> 可以增加代码的可读性和安全性，减少因为隐式转换带来的潜在问题。</p><p>这两个构造函数分别是：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread_pool</span><span class="params">(<span class="type">const</span> <span class="type">concurrency_t</span> num_threads)</span> : thread_pool(num_threads, [] &#123;</span>&#125;) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread_pool</span><span class="params">(<span class="type">const</span> std::function&lt;<span class="type">void</span>()&gt;&amp; init_task)</span> : thread_pool(<span class="number">0</span>, init_task) &#123;</span>&#125;</span><br></pre></td></tr></table></figure><p></p><ol><li><code>explicit thread_pool(const concurrency_t num_threads)</code></li></ol><p>如果不加 <code>explicit</code> ，这个构造函数会允许隐式转换。例如：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread_pool pool = <span class="number">4</span>;  <span class="comment">// 可能会导致意外的隐式转换</span></span><br></pre></td></tr></table></figure><p></p><p>加上 <code>explicit</code> 后，这种隐式转换将被禁止，必须显式调用构造函数：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread_pool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;  <span class="comment">// 必须显式调用构造函数</span></span><br></pre></td></tr></table></figure><p></p><ol start="2"><li><code>explicit thread_pool(const std::function&lt;void()&gt;&amp; init_task)</code></li></ol><p>类似地，如果不加 <code>explicit</code> ，这个构造函数也会允许隐式转换。例如：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">void</span>()&gt; init_task = [] &#123;&#125;;</span><br><span class="line">thread_pool pool = init_task;  <span class="comment">// 可能会导致意外的隐式转换</span></span><br></pre></td></tr></table></figure><p></p><p>加上 <code>explicit</code> 后，这种隐式转换也将被禁止，必须显式调用构造函数：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread_pool <span class="title">pool</span><span class="params">(init_task)</span></span>;  <span class="comment">// 必须显式调用构造函数</span></span><br></pre></td></tr></table></figure><p></p><p>通过在构造函数前加 <code>explicit</code> ，可以防止对象在不小心的隐式转换中被意外构造。这对于构造函数接受单一参数的情况特别有用，因为这种情况下编译器会自动尝试进行隐式转换。如果没有 <code>explicit</code> ，程序员可能会在不经意间触发这些转换，从而导致难以调试的错误。</p><p>使用 <code>explicit</code> 可以增强代码的可读性和安全性，强制要求调用者显式地创建对象，避免意外的隐式转换行为。</p><h3 id="i-stdunique_ptrt"><a class="anchor" href="#i-stdunique_ptrt">#</a> i、 <code>std::unique_ptr&lt;T[]&gt;</code></h3><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;std::thread[]&gt; threads = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p></p><p>这行代码创建了一个名为 <code>threads</code> 的变量，该变量是一个指向 <code>std::thread</code> 对象数组的智能指针。</p><p>对于 <strong><code>std::unique_ptr&lt;std::thread[]&gt;</code> </strong>:</p><ul><li><code>std::unique_ptr</code> 是一个模板类，用于独占式地管理动态分配的资源（通常是通过 <code>new</code> 分配的内存）。当 <code>std::unique_ptr</code> 对象被销毁时，它会自动释放所管理的资源。</li><li><code>std::unique_ptr&lt;T[]&gt;</code> 是 <code>std::unique_ptr</code> 的一个特殊实例，用于管理动态分配的数组。与管理单个对象的 <code>std::unique_ptr&lt;T&gt;</code> 不同， <code>std::unique_ptr&lt;T[]&gt;</code> 用于管理数组（即动态分配的多个对象）。</li><li>在这个例子中， <code>T</code> 是 <code>std::thread</code> ，所以 <code>std::unique_ptr&lt;std::thread[]&gt;</code> 是一个指向 <code>std::thread</code> 对象数组的智能指针。</li></ul><p>这行代码的作用是声明并初始化一个智能指针 <code>threads</code> ，它能够独占地管理一个 <code>std::thread</code> 对象数组，但在初始化时并没有分配任何 <code>std::thread</code> 对象数组。此时， <code>threads</code> 是一个空指针，不指向任何内存。</p><p>于是，进一步地，我们回过头看刚才的主构造函数：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">thread_pool</span>(<span class="type">const</span> <span class="type">concurrency_t</span> num_threads, <span class="type">const</span> std::function&lt;<span class="built_in">void</span>()&gt;&amp; init_task)</span><br><span class="line">    : <span class="built_in">thread_count</span>(<span class="built_in">determine_thread_count</span>(num_threads)), </span><br><span class="line">      <span class="built_in">threads</span>(std::<span class="built_in">make_unique</span>&lt;std::thread[]&gt;(<span class="built_in">determine_thread_count</span>(num_threads)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">create_threads</span>(init_task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里的 <strong><code>std::make_unique&lt;std::thread[]&gt;(...)</code> </strong>：</p><ul><li><code>std::make_unique</code> 是一个用于创建 <code>std::unique_ptr</code> 的工厂函数。它在 C++14 中引入，用于安全且简洁地创建 <code>std::unique_ptr</code> 对象。</li><li><code>std::make_unique&lt;std::thread[]&gt;</code> 表示创建一个指向 <code>std::thread</code> 对象数组的 <code>std::unique_ptr</code></li><li><code>std::make_unique&lt;std::thread[]&gt;(n)</code> 创建一个包含 <code>n</code> 个 <code>std::thread</code> 对象的数组，并返回一个指向该数组的 <code>std::unique_ptr</code> 。</li></ul><h3 id="i-thread-绑定成员函数"><a class="anchor" href="#i-thread-绑定成员函数">#</a> i、thread 绑定成员函数</h3><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_threads</span><span class="params">(<span class="type">const</span> std::function&lt;<span class="type">void</span>()&gt;&amp; init_task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">const</span> std::scoped_lock <span class="title">tasks_lock</span><span class="params">(tasks_mutex)</span></span>;</span><br><span class="line">        tasks_running = thread_count;</span><br><span class="line">        workers_running = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">concurrency_t</span> i = <span class="number">0</span>; i &lt; thread_count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(&amp;thread_pool::worker, <span class="keyword">this</span>, i, init_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>create_threads</code> 函数的作用是：</p><ol><li>使用一个 <code>std::scoped_lock</code> 来保护对共享资源的访问，确保 <code>tasks_running</code> 和 <code>workers_running</code> 的设置是线程安全的。（关于 <code>scoped_lock</code> 的更多细节，见 <a href="https://how2051.github.io/2024/10/12/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/#4-scoped_lock">scpoed_lock</a>）</li><li>使用一个循环来创建和启动多个线程，并将这些线程存储在 <code>threads</code> 数组中。每个线程都会调用 <code>thread_pool</code> 类的成员函数 <code>worker</code> ，并传递当前线程的索引和初始化任务。</li></ol><p>这个函数有效地初始化了一个线程池，其中每个线程在启动时都会执行 <code>worker</code> 函数，并在启动之前执行 <code>init_task</code> 函数。</p><p>这里具体来看看线程的创建：</p><ul><li><code>threads[i] = std::thread(&amp;thread_pool::worker, this, i, init_task);</code> ：在 <code>threads</code> 数组的第 <code>i</code> 个位置创建一个新的 <code>std::thread</code> 对象，并启动该线程。<ul><li><code>std::thread(&amp;thread_pool::worker, this, i, init_task)</code> ：创建一个新的线程，并将其绑定到 <code>thread_pool</code> 类的成员函数 <code>worker</code> 上。<ul><li><code>&amp;thread_pool::worker</code> ：指向 <code>worker</code> 成员函数的指针。</li><li><code>this</code> ：指向当前的 <code>thread_pool</code> 实例。</li><li><code>i</code> ：传递给 <code>worker</code> 函数的线程索引。</li><li><code>init_task</code> ：传递给 <code>worker</code> 函数的初始化任务。</li></ul></li></ul></li></ul><p>进一步地，我们关注 thread 参数的传递：—— 为什么要传递 <code>this</code> 指针？<br><code>threads[i] = std::thread(&amp;thread_pool::worker, this, i, init_task);</code> 这行代码创建并启动了一个新线程，该线程将执行 <code>thread_pool</code> 类的成员函数 <code>worker</code> 。为了理解这行代码，尤其是为什么要传递 <code>this</code> 指针，我们需要详细解释一下成员函数绑定和线程创建的过程。</p><p>成员函数绑定</p><p>在 C++ 中，成员函数和普通的非成员函数不同，成员函数需要一个对象实例来调用它。成员函数实际上需要两个东西：</p><ol><li>成员函数本身的地址。</li><li>一个对象实例（通过 <code>this</code> 指针）来调用该成员函数。</li></ol><p>代码解释</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threads[i] = std::<span class="built_in">thread</span>(&amp;thread_pool::worker, <span class="keyword">this</span>, i, init_task);</span><br></pre></td></tr></table></figure><p></p><p>这行代码的每个部分解释如下：</p><ol><li><p><strong><code>std::thread</code> 构造函数</strong>:</p><ul><li><code>std::thread</code> 是 C++ 标准库中的一个类，用于创建和管理线程。</li><li><code>std::thread</code> 的构造函数可以接受一个可调用对象（函数指针、成员函数指针、lambda 表达式等）和一组参数。这些参数会传递给可调用对象。</li></ul></li><li><p><strong><code>&amp;thread_pool::worker</code> </strong>:</p><ul><li><code>&amp;thread_pool::worker</code> 是一个指向 <code>thread_pool</code> 类成员函数 <code>worker</code> 的指针。</li><li>由于 <code>worker</code> 是一个成员函数，它需要一个 <code>thread_pool</code> 实例来调用。</li></ul></li><li><p><strong><code>this</code> </strong>:</p><ul><li><code>this</code> 指针指向当前的 <code>thread_pool</code> 实例。</li><li>通过传递 <code>this</code> 指针， <code>std::thread</code> 构造函数能够知道在哪个 <code>thread_pool</code> 实例上调用 <code>worker</code> 成员函数。</li></ul></li><li><p><strong>参数传递</strong>:</p><ul><li><code>i</code> 和 <code>init_task</code> 是传递给 <code>worker</code> 函数的参数。</li></ul></li></ol><p>当你创建一个新的线程并希望在线程中运行一个成员函数时，你需要告诉线程该成员函数属于哪个对象实例。通过传递 <code>this</code> 指针，新的线程就知道在当前 <code>thread_pool</code> 实例上调用 <code>worker</code> 函数。</p><p>传递 <code>this</code> 指针是为了让新创建的线程知道在哪个对象实例上调用成员函数。这样，成员函数就能够<mark>正确访问和操作该对象实例的成员变量</mark>和其他成员函数。这是成员函数与非成员函数的一个重要区别，确保在多线程环境中能够正确地工作。</p><p>对于 thread 的使用，可参考 [[thread# 构造函数及其参数 | thread]]</p><h3 id="i-移动拷贝和移动赋值"><a class="anchor" href="#i-移动拷贝和移动赋值">#</a> i、移动拷贝和移动赋值</h3><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">thread_pool</span>(<span class="type">const</span> thread_pool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="built_in">thread_pool</span>(thread_pool&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">thread_pool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> thread_pool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">thread_pool&amp; <span class="keyword">operator</span>=(thread_pool&amp;&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><p></p><p>这里禁用了拷贝构造、移动构造和移动赋值函数。</p><p>关于移动拷贝和移动赋值，下面是一些使用示例：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// For std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="built_in">int</span>(value)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructed with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>;  <span class="comment">// 移动后，源对象的指针被置为nullptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move constructed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span> data;        <span class="comment">// 释放当前对象的资源</span></span><br><span class="line">            data = other.data;  <span class="comment">// 转移资源</span></span><br><span class="line">            other.data = <span class="literal">nullptr</span>;  <span class="comment">// 源对象的指针被置为nullptr</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Move assigned&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destroyed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用构造函数创建对象</span></span><br><span class="line">    <span class="function">MyClass <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用移动构造函数</span></span><br><span class="line">    <span class="function">MyClass <span class="title">b</span><span class="params">(std::move(a))</span></span>;  <span class="comment">// 触发移动构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用构造函数创建另一个对象</span></span><br><span class="line">    <span class="function">MyClass <span class="title">c</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用移动赋值运算符</span></span><br><span class="line">    c = std::<span class="built_in">move</span>(b);         <span class="comment">// 触发移动赋值运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><strong>移动构造和移动赋值的意义</strong>：通过移动构造和移动赋值，我们可以高效地转移资源，避免不必要的深拷贝。</li><li><strong>删除移动构造和移动赋值</strong>：在某些情况下，为了确保资源管理的安全性，可以禁用移动构造函数和移动赋值运算符，防止对象被意外地移动。</li></ul><h3 id="i-mutable-mutex"><a class="anchor" href="#i-mutable-mutex">#</a> i、mutable mutex</h3><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable</span> std::mutex tasks_mutex = &#123;&#125;;</span><br></pre></td></tr></table></figure><p></p><p>这行代码定义并初始化了一个可变的互斥锁（ <code>std::mutex</code> ），这里主要讨论 mutable：</p><p><code>mutable</code> 关键字允许即使在一个 <code>const</code> 成员函数中也可以修改这个成员变量。通常，成员变量在 <code>const</code> 成员函数中是不可修改的，但使用 <code>mutable</code> 关键字可以使这个限制失效。</p><p>在多线程编程中，一个常见的使用场景是，当一个类的成员函数声明为 <code>const</code> 时，<mark>我们可能仍需要锁定互斥锁来保护共享数据</mark>。这时就需要将互斥锁声明为 <code>mutable</code> 。</p><p>总得来说，这行代码定义了一个名为 <code>tasks_mutex</code> 的互斥锁，并将其声明为 <code>mutable</code> ，这样它可以在任何成员函数中（包括 <code>const</code> 成员函数）被修改。默认初始化器 <code>&#123;&#125;</code> 用于默认构造 <code>tasks_mutex</code> ，即互斥锁处于未锁定状态。</p><h3 id="i-lambda-表达式捕获-this-指针"><a class="anchor" href="#i-lambda-表达式捕获-this-指针">#</a> i、lambda 表达式捕获 this 指针</h3><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock <span class="title">tasks_lock</span><span class="params">(tasks_mutex)</span></span>;</span><br><span class="line">    waiting = <span class="literal">true</span>;</span><br><span class="line">    tasks_done_cv.<span class="built_in">wait</span>(tasks_lock,</span><br><span class="line">        [<span class="keyword">this</span>]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">return</span> (tasks_running == <span class="number">0</span>) &amp;&amp; BS_THREAD_POOL_PAUSED_OR_EMPTY;</span><br><span class="line">        &#125;);</span><br><span class="line">    waiting = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这段代码定义了一个名为 <code>wait</code> 的成员函数，它的作用是在某些条件满足之前使当前线程进入等待状态。它使用 <code>std::unique_lock</code> 和 <code>std::condition_variable</code> 来实现线程同步。</p><p>这里主要讨论 <code>std::condition_variable</code> 的 wait 以及 lambda 表达式：</p><ol><li><code>tasks_done_cv.wait</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tasks_done_cv.<span class="built_in">wait</span>(tasks_lock,</span><br><span class="line">    [<span class="keyword">this</span>]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> (tasks_running == <span class="number">0</span>) &amp;&amp; BS_THREAD_POOL_PAUSED_OR_EMPTY;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ol><p>这里， <code>tasks_done_cv</code> 是一个 <code>std::condition_variable</code> 对象，用于实现线程之间的等待和通知机制。</p><ul><li><code>tasks_done_cv.wait(tasks_lock, ...)</code> ：这行代码让当前线程进入等待状态，直到条件变量被通知并且条件表达式返回 <code>true</code> 。</li><li><code>tasks_lock</code> ：条件变量等待时会释放这个锁，等到被通知后再重新锁定它。</li><li><code>[this] &#123; ... &#125;</code> ：这是一个 lambda 表达式，用于定义等待的条件。</li></ul><ol start="2"><li>Lambda 表达式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">this</span>]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (tasks_running == <span class="number">0</span>) &amp;&amp; BS_THREAD_POOL_PAUSED_OR_EMPTY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个 lambda 表达式捕获 <code>this</code> 指针，访问类的成员变量，并返回一个布尔值。具体条件是：</p><ul><li><code>(tasks_running == 0)</code> ：表示没有正在运行的任务。</li><li><code>BS_THREAD_POOL_PAUSED_OR_EMPTY</code> ：一个宏或常量，表示线程池要么处于暂停状态，要么任务队列为空。</li></ul><p>只有在这两个条件都满足时，lambda 表达式才会返回 <code>true</code> ，从而使 <code>wait</code> 函数解除等待状态。</p><blockquote><p>追问：这里这个 wait 本身就已经是成员函数了，为什么在条件变量的 wait 函数中传递的 lambda 表达式还需要捕获 <code>this</code> 指针呢？</p></blockquote><p>在 C++ 中，成员函数会隐式地包含一个 <code>this</code> 指针，用于指向调用该函数的对象。然而，lambda 表达式默认不捕获任何外部变量，包括成员函数的 <code>this</code> 指针。如果需要在 lambda 表达式中访问成员变量或成员函数，必须显式地捕获 <code>this</code> 指针。</p><p>在上述代码中，lambda 表达式需要访问类的成员变量 <code>tasks_running</code> 和 <code>BS_THREAD_POOL_PAUSED_OR_EMPTY</code> 。为了使 lambda 表达式能够访问这些成员变量，必须捕获 <code>this</code> 指针。具体来说， <code>this</code> 指针允许 lambda 表达式访问当前对象的成员。</p><p>如果不捕获 <code>this</code> 指针，lambda 表达式将无法访问 <code>tasks_running</code> 和 <code>BS_THREAD_POOL_PAUSED_OR_EMPTY</code> ，编译器会报错。</p><p>lambda 表达式默认不捕获任何外部变量，包括成员函数的 <code>this</code> 指针。如果需要在 lambda 表达式中访问成员变量或成员函数，必须显式地捕获 <code>this</code> 指针。因此，在代码中，为了在 lambda 表达式中访问 <code>tasks_running</code> 和 <code>BS_THREAD_POOL_PAUSED_OR_EMPTY</code> ，必须捕获 <code>this</code> 指针。</p><h3 id="i-优先队列"><a class="anchor" href="#i-优先队列">#</a> i、优先队列</h3><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> BS_THREAD_POOL_ENABLE_PRIORITY</span></span><br><span class="line">    std::priority_queue&lt;pr_task&gt; tasks = &#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks = &#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p></p><ol><li><p><strong><code>std::priority_queue&lt;pr_task&gt; tasks = &#123;&#125;;</code> </strong>：</p><ul><li>声明并初始化一个名为 <code>tasks</code> 的优先级队列。这个优先级队列用于存储类型为 <code>pr_task</code> 的任务。 <code>pr_task</code> 应该是一个自定义类型，用于表示带有优先级的任务。</li><li>优先级队列 <code>std::priority_queue</code> 会根据任务的优先级来自动排序，保证高优先级的任务先被处理。</li></ul></li><li><p><strong><code>std::queue&lt;std::function&lt;void()&gt;&gt; tasks = &#123;&#125;;</code> </strong>：</p><ul><li>声明并初始化一个名为 <code>tasks</code> 的普通队列。这个普通队列用于存储 <code>std::function&lt;void()&gt;</code> 类型的任务。</li><li>普通队列 <code>std::queue</code> 是一个先进先出（FIFO）的数据结构，任务会按照添加的顺序依次被处理。</li></ul></li></ol><p>这里展开讲一下 <a href="https://how2051.github.io/2024/10/12/C-%E5%BA%93%E5%87%BD%E6%95%B0/#i-priority_queue">优先队列</a>：</p><p><code>std::priority_queue</code> 是一种适用于需要快速访问最大（或最小）元素的场景的容器。它通常用于调度任务、管理事件或需要优先处理的其他情况。 <code>std::priority_queue</code> 本质上是一个<strong>最大堆</strong>（max-heap），默认情况下它总是保证堆顶元素是最大值。</p><ol><li>应用场景</li></ol><ul><li><strong>任务调度</strong>：需要根据优先级处理任务时， <code>std::priority_queue</code> 可以确保高优先级任务先被处理。</li><li><strong>事件管理</strong>：在模拟系统中，可以使用优先队列来处理时间戳最小的事件。</li><li><strong>路径搜索算法</strong>：如 <code>Dijkstra</code> 算法和 <code>A*</code> 算法，用于管理待处理节点。</li></ul><ol start="2"><li><p>底层原理<br><code>std::priority_queue</code> 通常基于堆（heap）数据结构实现。堆是一种特殊的二叉树，可以用数组来表示。最大堆的特点是每个节点的值都大于或等于其子节点的值。C++ 标准库使用 <code>std::vector</code> 作为底层容器，并使用 <code>std::push_heap</code> 和 <code>std::pop_heap</code> 等算法来维护堆的性质。</p></li><li><p>普通类型的使用<br>默认情况下， <code>std::priority_queue</code> 是最大堆。如果需要最小堆，可以使用 <code>std::greater&lt;T&gt;</code> 比较器</p></li><li><p>自定义复杂类型的使用</p></li></ol><p>对于自定义类型，<mark>需要提供比较器来定义优先级</mark> —— 实质上就是重载 <code>&lt;</code> 运算符。<br>例如，假设我们有一个 <code>Task</code> 结构：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    std::string description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义比较器，用于优先队列</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Task&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> priority &lt; other.priority;  <span class="comment">// 优先级越高越优先</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::priority_queue&lt;Task&gt; task_pq;</span><br><span class="line"></span><br><span class="line">    task_pq.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="string">&quot;Low priority task&quot;</span>&#125;);</span><br><span class="line">    task_pq.<span class="built_in">push</span>(&#123;<span class="number">3</span>, <span class="string">&quot;High priority task&quot;</span>&#125;);</span><br><span class="line">    task_pq.<span class="built_in">push</span>(&#123;<span class="number">2</span>, <span class="string">&quot;Medium priority task&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!task_pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">const</span> Task&amp; task = task_pq.<span class="built_in">top</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Priority: &quot;</span> &lt;&lt; task.priority &lt;&lt; <span class="string">&quot;, Description: &quot;</span> &lt;&lt; task.description &lt;&lt; std::endl;</span><br><span class="line">        task_pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上述代码将输出：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Priority: 3, Description: High priority task</span><br><span class="line">Priority: 2, Description: Medium priority task</span><br><span class="line">Priority: 1, Description: Low priority task</span><br></pre></td></tr></table></figure><p></p><p><code>std::priority_queue</code> 是一个强大的数据结构，适用于许多需要优先级处理的场景。通过灵活地定义比较器和底层容器，可以适应各种具体需求。</p><p>此时我们再回过头来看 <code>pr_task</code> 的定义，便一目了然：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> [[nodiscard]] pr_task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">thread_pool</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">pr_task</span><span class="params">(<span class="type">const</span> std::function&lt;<span class="type">void</span>()&gt;&amp; task_, <span class="type">const</span> <span class="type">priority_t</span> priority_ = <span class="number">0</span>)</span> : task(task_), priority(priority_) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">pr_task</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt;&amp;&amp; task_, <span class="type">const</span> <span class="type">priority_t</span> priority_ = <span class="number">0</span>)</span> : task(std::move(task_)), priority(priority_) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> pr_task&amp; lhs, <span class="type">const</span> pr_task&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.priority &lt; rhs.priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; task = &#123;&#125;;</span><br><span class="line">    <span class="type">priority_t</span> priority = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h3 id="i-stdoptional"><a class="anchor" href="#i-stdoptional">#</a> i、std::optional</h3><p>#CPP17<br><code>std::optional</code> 是 C++17 引入的一个标准库模板类，用于表示一个可能包含或不包含值的对象。它是一个类型安全的替代方案，用于表示函数的返回值可能为空的情况，避免使用指针或特定的标记值。</p><h5 id="stdoptional-的定义"><a class="anchor" href="#stdoptional-的定义">#</a> <code>std::optional</code> 的定义</h5><p><code>std::optional</code> 是一个模板类，其定义类似于：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">optional</span>;</span><br></pre></td></tr></table></figure><p></p><p>它可以包含一个类型为 <code>T</code> 的值，也可以不包含任何值。</p><h5 id="主要功能和用法"><a class="anchor" href="#主要功能和用法">#</a> 主要功能和用法</h5><ol><li>创建 <code>std::optional</code> 对象</li></ol><p>你可以通过默认构造函数、初始化构造函数或使用工厂函数来创建一个 <code>std::optional</code> 对象。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::optional&lt;<span class="type">int</span>&gt; opt1;           <span class="comment">// 不包含值</span></span><br><span class="line">std::optional&lt;<span class="type">int</span>&gt; opt2 = <span class="number">42</span>;      <span class="comment">// 包含值 42</span></span><br><span class="line"><span class="keyword">auto</span> opt3 = std::<span class="built_in">make_optional</span>(<span class="number">42</span>); <span class="comment">// 包含值 42</span></span><br></pre></td></tr></table></figure><p></p><ol start="2"><li>检查是否包含值<br>使用 <code>has_value()</code> 方法或布尔运算符来检查 <code>std::optional</code> 对象是否包含值。</li></ol><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (opt2.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    <span class="comment">// opt2 包含值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (opt2) &#123;</span><br><span class="line">    <span class="comment">// opt2 包含值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ol start="3"><li>访问包含的值</li></ol><p>可以使用 <code>value()</code> 方法或者解引用运算符 <code>*</code> 和箭头运算符 <code>-&gt;</code> 来访问包含的值。</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = opt2.<span class="built_in">value</span>(); <span class="comment">// 如果 opt2 不包含值，会抛出 std::bad_optional_access 异常</span></span><br><span class="line"><span class="type">int</span> value = *opt2;        <span class="comment">// 如果 opt2 不包含值，行为未定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用箭头运算符访问成员</span></span><br><span class="line">std::optional&lt;std::string&gt; optStr = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; optStr-&gt;<span class="built_in">length</span>() &lt;&lt; std::endl; <span class="comment">// 打印 5</span></span><br></pre></td></tr></table></figure><p></p><ol start="4"><li>获取默认值</li></ol><p>使用 <code>value_or()</code> 方法可以在 <code>std::optional</code> 对象不包含值时提供一个默认值。</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = opt1.<span class="built_in">value_or</span>(<span class="number">0</span>); <span class="comment">// 如果 opt1 不包含值，则返回默认值 0</span></span><br></pre></td></tr></table></figure><p></p><ol start="5"><li>赋值和重置</li></ol><p>你可以向 <code>std::optional</code> 对象赋值，也可以通过调用 <code>reset()</code> 方法将其重置为不包含值的状态。</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opt1 = <span class="number">10</span>;      <span class="comment">// opt1 现在包含值 10</span></span><br><span class="line">opt1.<span class="built_in">reset</span>();   <span class="comment">// opt1 现在不包含值</span></span><br></pre></td></tr></table></figure><p></p><h5 id="stdoptional-的使用场景"><a class="anchor" href="#stdoptional-的使用场景">#</a> <code>std::optional</code> 的使用场景</h5><p><code>std::optional</code> 非常适合用来处理函数可能返回空值或无效值的情况：</p><ol><li><strong>函数返回值</strong>：当函数可能无法返回有效结果时，使用 <code>std::optional</code> 比返回指针或特殊值（如 <code>-1</code> 或 <code>NULL</code> ）更加安全和可读。</li></ol><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">find_name</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>; <span class="comment">// 或者 return &#123;&#125;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ol start="2"><li><p><strong>延迟初始化</strong>：当一个变量的初始化依赖某些条件时，可以使用 <code>std::optional</code> 来延迟初始化。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::optional&lt;std::string&gt; name;</span><br><span class="line"><span class="keyword">if</span>(condition) &#123;</span><br><span class="line">    name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>（这里举的例子不是特别好，它大致要表达的意思是，这里 name 并没有立即被初始化、调用构造函数，而是在条件满足之后在赋值时才初始化。）<p></p></li><li><p><strong>配置选项</strong>：在配置文件或命令行参数解析中，可以使用 <code>std::optional</code> 来表示某个选项是否被提供。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::optional&lt;<span class="type">int</span>&gt; port = <span class="built_in">get_port_from_config</span>();</span><br><span class="line"><span class="keyword">if</span>(port) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using port: &quot;</span> &lt;&lt; *port &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using default port&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol><h3 id="i-继承构造函数"><a class="anchor" href="#i-继承构造函数">#</a> i、继承构造函数</h3><p>#CPP11<br>C++ 的继承构造函数（inheriting constructors）是 C++11 引入的一项特性，旨在简化继承体系中的构造函数定义。这一特性使得派生类可以直接继承并使用基类的构造函数，减少代码冗余和重复工作。</p><ol><li><p>基本概念<br>继承构造函数允许派生类继承基类的所有构造函数，而无需显式地在派生类中重新定义它们。这是通过在派生类中使用 <code>using</code> 声明实现的。</p></li><li><p>语法<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base; <span class="comment">// 继承Base类的所有构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li></ol><h5 id="示例"><a class="anchor" href="#示例">#</a> 示例</h5><p>假设我们有一个基类 <code>Base</code> ，以及一个派生类 <code>Derived</code> ，我们希望派生类能够继承基类的所有构造函数。</p><ol><li><p>基类定义<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li><li><p>派生类定义<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base; <span class="comment">// 继承Base类的所有构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li><li><p>使用<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">d1</span><span class="params">(<span class="number">10</span>)</span></span>;      <span class="comment">// 使用Base(int x)构造函数</span></span><br><span class="line">    <span class="function">Derived <span class="title">d2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  <span class="comment">// 使用Base(int x, int y)构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol><h5 id="继承构造函数的优点"><a class="anchor" href="#继承构造函数的优点">#</a> 继承构造函数的优点</h5><ol><li><strong>减少代码重复</strong>：无需在派生类中重复定义基类已有的构造函数。</li><li><strong>简化代码维护</strong>：基类构造函数的修改自动反映到派生类，无需额外修改派生类。</li><li><strong>提高代码可读性</strong>：代码更简洁明了，容易理解。</li></ol><h5 id="继承构造函数的限制和注意事项"><a class="anchor" href="#继承构造函数的限制和注意事项">#</a> 继承构造函数的限制和注意事项</h5><ol><li><strong>继承构造函数无法继承默认构造函数</strong>：如果基类只有用户定义的构造函数且没有默认构造函数，派生类需要显式定义一个默认构造函数。</li><li><strong>继承构造函数无法继承析构函数</strong>：析构函数不会被继承，即使使用继承构造函数，派生类的析构函数仍然需要单独定义。</li><li><strong>菱形继承问题</strong>：在多重继承的情况下，使用继承构造函数可能会引发菱形继承问题，需要小心处理。</li></ol><h5 id="实际应用示例"><a class="anchor" href="#实际应用示例">#</a> 实际应用示例</h5><ol><li><p>基类和派生类的定义<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Person::Person;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li><li><p>使用派生类的构造函数<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Employee <span class="title">e1</span><span class="params">(<span class="string">&quot;Alice&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Employee <span class="title">e2</span><span class="params">(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol><h5 id="在-bs_thread_pool-中的使用"><a class="anchor" href="#在-bs_thread_pool-中的使用">#</a> 在 BS_thread_pool 中的使用</h5><p>具体地，在 <code>BS_thread_pool</code> 中，在 <code>multi_future</code> 类的定义中使用了这一语法：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> [[nodiscard]] multi_future : <span class="keyword">public</span> std::vector&lt;std::future&lt;T&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Inherit all constructors from the base class `std::vector`.</span></span><br><span class="line">    <span class="keyword">using</span> std::vector&lt;std::future&lt;T&gt;&gt;::vector;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这行代码是一个使用了 <code>using</code> 关键字的构造函数继承声明。<br>具体来说，它是继承了 <code>std::vector&lt;std::future&lt;T&gt;&gt;</code> 类的构造函数。</p><ol><li><p><code>std::vector&lt;std::future&lt;T&gt;&gt;</code><br><code>std::vector&lt;std::future&lt;T&gt;&gt;</code> 是一个容器类，存储了多个 <code>std::future&lt;T&gt;</code> 对象。 <code>std::future&lt;T&gt;</code> 是用于表示异步操作结果的标准库类型。</p></li><li><p><code>using</code><br><code>using</code> 关键字在这种上下文中用来继承构造函数。这是 C++11 引入的一项特性，允许一个类继承其基类的构造函数。通过继承构造函数，派生类可以直接使用基类的构造函数初始化自己，而不需要重新定义这些构造函数。</p></li><li><p><code>using std::vector&lt;std::future&lt;T&gt;&gt;::vector</code><br>这行代码的意思是让当前类（假设当前类是某个类的派生类）继承 <code>std::vector&lt;std::future&lt;T&gt;&gt;</code> 的所有构造函数。这样一来，你可以使用 <code>std::vector&lt;std::future&lt;T&gt;&gt;</code> 的各种构造函数来构造你的派生类对象。</p></li></ol><h3 id="i-stdconditional_t-和-stdis_void_v"><a class="anchor" href="#i-stdconditional_t-和-stdis_void_v">#</a> i、 <code>std::conditional_t</code> 和 <code>std::is_void_v</code></h3><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] std::<span class="type">conditional_t</span>&lt;std::is_void_v&lt;T&gt;, <span class="type">void</span>, std::vector&lt;T&gt;&gt; <span class="built_in">get</span>()</span><br></pre></td></tr></table></figure><p></p><p>这个函数的返回值类型使用了一些 C++ 模板编程和条件编译的高级特性。</p><ul><li><code>[[nodiscard]]</code> ：这是一个属性，表示调用者不应忽略这个函数的返回值。</li><li><code>std::conditional_t&lt;std::is_void_v&lt;T&gt;, void, std::vector&lt;T&gt;&gt;</code> ：这部分是函数的返回类型。<br>它使用了 <code>std::conditional_t</code> 和 <code>std::is_void_v&lt;T&gt;</code> 来根据模板参数 <code>T</code> 的类型选择返回类型。<ul><li><code>std::is_void_v&lt;T&gt;</code> ：这是一个类型特征，用来检测 <code>T</code> 是否为 <code>void</code> 。如果 <code>T</code> 是 <code>void</code> ，则其值为 <code>true</code> ，否则为 <code>false</code> 。</li><li><code>std::conditional_t&lt;condition, true_type, false_type&gt;</code> ：这是一个条件类型，根据 <code>condition</code> 的值选择返回类型。如果 <code>condition</code> 为 <code>true</code> ，则返回 <code>true_type</code> ，否则返回 <code>false_type</code> 。</li><li>因此， <code>std::conditional_t&lt;std::is_void_v&lt;T&gt;, void, std::vector&lt;T&gt;&gt;</code> 表示如果 <code>T</code> 是 <code>void</code> ，则函数返回 <code>void</code> 类型，否则返回 <code>std::vector&lt;T&gt;</code> 类型。</li></ul></li></ul><h3 id="i-if-constexpr"><a class="anchor" href="#i-if-constexpr">#</a> i、if constexpr</h3><p>#CPP17</p><ul><li><code>if constexpr</code> 是 C++17 引入的一种条件编译指令。与传统的 <code>if</code> 语句不同， <code>if constexpr</code> 在编译时对条件表达式求值，并根据结果选择编译哪一段代码。如果条件为 <code>true</code> ，则编译 <code>if constexpr</code> 块内的代码；如果条件为 <code>false</code> ，则编译 <code>else</code> 块内的代码。</li><li>这意味着在编译时就能确定哪一段代码会被编译，而另一段代码则会被完全忽略。这对于模板编程尤其有用，因为它可以避免在编译期检测不到的非法代码。</li></ul><h3 id="i-构造函数的禁用"><a class="anchor" href="#i-构造函数的禁用">#</a> i、构造函数的禁用</h3><p>在 C++ 中，有些类的拷贝构造函数、拷贝赋值运算、移动构造函数、移动赋值运算符会被显式地禁用（通过 <code>delete</code> 关键字）。这样做的原因通常是为了避免对象的错误复制，保护资源的独占性或者防止出现不期望的行为。以下是几种常见的情况以及每种情况下为什么要禁用构造函数：</p><ol><li><strong>管理独占资源</strong></li></ol><p>如果一个类管理独占资源（例如文件句柄、网络连接、内存等），则应禁用拷贝操作以防止多个对象试图管理同一个资源。这会导致资源冲突和意外行为。</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileHandler</span>(<span class="type">const</span> std::string&amp; filename) &#123;</span><br><span class="line">        <span class="comment">// 打开文件并获取文件句柄</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">FileHandler</span>() &#123;</span><br><span class="line">        <span class="comment">// 关闭文件并释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造函数和拷贝赋值运算符</span></span><br><span class="line">    <span class="built_in">FileHandler</span>(<span class="type">const</span> FileHandler&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    FileHandler&amp; <span class="keyword">operator</span>=(<span class="type">const</span> FileHandler&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> file_descriptor; <span class="comment">// 文件句柄</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><ol start="2"><li><strong>防止不安全的深拷贝</strong></li></ol><p>有些类包含指向动态分配内存的指针。拷贝这些对象需要实现深拷贝操作，否则会导致浅拷贝问题（即多个对象指向同一块内存），这可能会引发双重释放（double free）或其他内存管理错误。如果不想实现深拷贝，最简单的方法是禁用拷贝。</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DynamicArray</span>(<span class="type">size_t</span> size) : <span class="built_in">size</span>(size), <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[size]) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">DynamicArray</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造函数和拷贝赋值运算符</span></span><br><span class="line">    <span class="built_in">DynamicArray</span>(<span class="type">const</span> DynamicArray&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    DynamicArray&amp; <span class="keyword">operator</span>=(<span class="type">const</span> DynamicArray&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><ol start="3"><li><strong>单例模式</strong></li></ol><p>单例模式要求一个类只有一个实例。为了防止创建多个实例，需要禁用拷贝构造函数和拷贝赋值运算符。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造函数和拷贝赋值运算符</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125; <span class="comment">// 私有构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><ol start="4"><li><strong>通过移动语义管理资源</strong></li></ol><p>有些类支持移动语义（move semantics），这意味着资源的所有权可以转移，而不是复制。在这种情况下，通常会禁用拷贝操作，只允许移动操作。</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UniqueResource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UniqueResource</span>(Resource&amp;&amp; resource) : <span class="built_in">resource</span>(std::<span class="built_in">move</span>(resource)) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 禁用拷贝构造函数和拷贝赋值运算符</span></span><br><span class="line">    <span class="built_in">UniqueResource</span>(<span class="type">const</span> UniqueResource&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    UniqueResource&amp; <span class="keyword">operator</span>=(<span class="type">const</span> UniqueResource&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许移动构造函数和移动赋值运算符</span></span><br><span class="line">    <span class="built_in">UniqueResource</span>(UniqueResource&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    UniqueResource&amp; <span class="keyword">operator</span>=(UniqueResource&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Resource resource;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><ol start="5"><li><strong>实现不可复制类型</strong></li></ol><p>有时候，一个类的语义意味着它不应该被复制，例如同步原语（mutex）或者一些逻辑控制类。在这种情况下，显式禁用拷贝操作是合适的。</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonCopyable</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造函数和拷贝赋值运算符</span></span><br><span class="line">    <span class="built_in">NonCopyable</span>(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h3 id="i-thread_local"><a class="anchor" href="#i-thread_local">#</a> i、thread_local</h3><p><code>thread_local</code> 关键字用于声明线程局部变量，使得每个线程有自己的独立实例。这些变量的生命周期与线程相同：线程开始时变量被创建，线程结束时变量被销毁。</p><p><strong>特点</strong></p><ol><li><strong>独立副本</strong>：每个线程都有自己的变量副本，变量之间互不干扰。</li><li><strong>自动初始化</strong>：每个线程在访问 <code>thread_local</code> 变量时，该变量会根据定义时的初始化表达式进行初始化。</li><li><strong>生命周期</strong>：变量的生命周期从线程创建开始，到线程结束为止。</li></ol><p><strong>语法</strong><br><code>thread_local</code> 关键字可以用于全局变量、局部变量和静态成员变量。使用方法如下：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> global_var = <span class="number">0</span>;  <span class="comment">// 全局线程局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> <span class="type">int</span> local_var = <span class="number">0</span>;  <span class="comment">// 局部线程局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">thread_local</span> <span class="type">int</span> static_member_var;  <span class="comment">// 静态成员线程局部变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> MyClass::static_member_var = <span class="number">0</span>;  <span class="comment">// 静态成员变量定义</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用场景</strong></p><ol><li><strong>线程安全</strong>：在多线程环境下使用全局变量或静态变量时，使用 <code>thread_local</code> 可以避免数据竞争。</li><li><strong>缓存局部数据</strong>：需要在线程中缓存一些局部数据，每个线程都有独立的缓存。</li><li><strong>性能优化</strong>：避免线程间同步开销，提升性能。</li></ol><p>以下是一个使用 <code>thread_local</code> 关键字的示例，展示了如何在多线程中使用线程局部变量：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">const</span> std::string&amp; thread_name)</span> </span>&#123;</span><br><span class="line">    ++counter;</span><br><span class="line">    std::cout &lt;&lt; thread_name &lt;&lt; <span class="string">&quot;: counter = &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment, <span class="string">&quot;Thread 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment, <span class="string">&quot;Thread 2&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread 1: counter = 1</span><br><span class="line">Thread 2: counter = 1</span><br></pre></td></tr></table></figure><p></p><p>从输出可以看出，每个线程都有自己独立的 <code>counter</code> 变量，互不干扰。</p><p><strong>关键点</strong></p><ol><li><strong>定义时机</strong>： <code>thread_local</code> 变量<mark>应在线程创建之前定义</mark>，以确保线程能够正确访问这些变量。</li><li><strong>内存开销</strong>：每个线程都有独立的变量副本，可能会增加内存使用量，尤其是变量占用较多内存时。</li><li><strong>初始化表达式</strong>：每个线程的 <code>thread_local</code> 变量使用相同的初始化表达式进行初始化。</li></ol><p>回到 <code>BS_thread_pool</code> 中，在命名空间 <code>this_thread</code> 中定义了两个 <code>thread_local</code> 的变量：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> this_thread &#123;</span><br><span class="line">    <span class="keyword">using</span> optional_index = std::optional&lt;<span class="type">size_t</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> optional_pool = std::optional&lt;thread_pool*&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> [[nodiscard]] thread_info_index</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BS</span>::thread_pool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        [[nodiscard]] <span class="function">optional_index <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        optional_index index = std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;; <span class="comment">// class thread_info_index</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> [[nodiscard]] thread_info_pool</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BS</span>::thread_pool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        [[nodiscard]] <span class="function">optional_pool <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pool;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        optional_pool pool = std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;; <span class="comment">// class thread_info_pool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">thread_local</span> thread_info_index get_index;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">thread_local</span> thread_info_pool get_pool;</span><br><span class="line">&#125; <span class="comment">// namespace this_thread</span></span><br></pre></td></tr></table></figure><p></p><p>然后，在 <code>thread_pool</code> 这个类中使用了上面的内容，这里以 <code>worker</code> 函数举例：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">const</span> <span class="type">concurrency_t</span> idx, <span class="type">const</span> std::function&lt;<span class="type">void</span>()&gt;&amp; init_task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    this_thread::get_index.index = idx;</span><br><span class="line">    this_thread::get_pool.pool = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">init_task</span>();</span><br><span class="line">    <span class="function">std::unique_lock <span class="title">tasks_lock</span><span class="params">(tasks_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    this_thread::get_index.index = std::<span class="literal">nullopt</span>;</span><br><span class="line">    this_thread::get_pool.pool = std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到这里我们对 <code>this_thread::get_index.index</code> 和 <code>this_thread::get_pool.pool</code> 进行了赋值。</p><p>那么，问题来了，为什么不直接在 <code>this_thread</code> 命名空间中定义 <code>index</code> 和 <code>pool</code> ，而还要加入两个类作为中间层？为什么不能如下：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> this_thread &#123;</span><br><span class="line">    <span class="keyword">using</span> optional_index = std::optional&lt;<span class="type">size_t</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> optional_pool = std::optional&lt;thread_pool*&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">thread_local</span> optional_index index = std::<span class="literal">nullopt</span>;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">thread_local</span> optional_pool pool = std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125; <span class="comment">// namespace this_thread</span></span><br></pre></td></tr></table></figure><p></p><p>在 <code>this_thread</code> 命名空间中直接定义两个变量 <code>index</code> 和 <code>pool</code> 是可以的，但使用类 <code>thread_info_index</code> 和 <code>thread_info_pool</code> 来封装这些变量也有其独特的优势和目的。</p><p>以下是一些关键原因：</p><ol><li>访问控制</li></ol><p>—— 在这里我觉得是主要的原因。</p><p>使用类可以更好地控制变量的访问权限。通过类的 <code>public</code> 和 <code>private</code> 成员，可以明确哪些成员可以被外部访问，哪些成员是内部实现细节。例如， <code>index</code> 和 <code>pool</code> 的设置和访问可以通过公有成员函数进行，而变量本身可以是私有的，从而防止意外修改。</p><ol start="2"><li>增强可读性和组织性</li></ol><p>使用类可以将相关的功能和数据组织在一起，使代码更具可读性和结构化。特别是当需要扩展功能时，可以方便地在类中添加新的成员函数，而不需要修改原有的全局变量定义。</p><ol start="3"><li>提供额外功能</li></ol><p>类可以包含额外的功能。例如，类可以提供特定的操作函数（如获取、设置、重置变量），而这些功能通过简单的全局变量是无法实现的。这样可以确保对变量的操作更加规范和受控。</p><ol start="4"><li>一致的接口</li></ol><p>通过类可以提供一致的接口，特别是在涉及多个类似功能的变量时。例如， <code>thread_info_index</code> 和 <code>thread_info_pool</code> 类都提供了一个一致的操作接口（ <code>operator()</code> ），这使得在代码中使用这些变量更加方便和统一。</p><div class="tags"><a href="/tags/CPP%E6%96%B0%E7%89%B9%E6%80%A7/" rel="tag"><i class="ic i-tag"></i> CPP新特性</a> <a href="/tags/CPP17/" rel="tag"><i class="ic i-tag"></i> CPP17</a> <a href="/tags/CPP11/" rel="tag"><i class="ic i-tag"></i> CPP11</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-10-22 16:48:58" itemprop="dateModified" datetime="2024-10-22T16:48:58+08:00">2024-10-22</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝杯咖啡吧~</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Rick how 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Rick how 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Rick how <i class="ic i-at"><em>@</em></i>how</li><li class="link"><strong>本文链接：</strong> <a href="https://how2051.github.io/2024/10/22/%E7%B2%97%E8%AF%BB-BS-thread-pool-%E6%9C%AD%E8%AE%B0/" title="粗读 BS_thread_pool 札记">https://how2051.github.io/2024/10/22/粗读-BS-thread-pool-札记/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/10/21/%E3%80%8AGoogle-C-Style-Guide%E3%80%8Bnote/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;ooo.0x0.ooo&#x2F;2023&#x2F;12&#x2F;08&#x2F;OAE0e6.jpg" title="《Google C++ Style Guide》note"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>《Google C++ Style Guide》note</h3></a></div><div class="item right"><a href="/2024/10/22/thread/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;ooo.0x0.ooo&#x2F;2023&#x2F;12&#x2F;08&#x2F;OAE0e6.jpg" title="thread"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> asynchronous</span><h3>thread</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#i-invoke_result_t"><span class="toc-number">1.</span> <span class="toc-text">i、invoke_result_t</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-nodiscard-class"><span class="toc-number">2.</span> <span class="toc-text">i、nodiscard class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">i、委托构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-explicit"><span class="toc-number">4.</span> <span class="toc-text">i、explicit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-stdunique_ptrt"><span class="toc-number">5.</span> <span class="toc-text">i、 std::unique_ptr&lt;T[]&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-thread-%E7%BB%91%E5%AE%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">i、thread 绑定成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-%E7%A7%BB%E5%8A%A8%E6%8B%B7%E8%B4%9D%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC"><span class="toc-number">7.</span> <span class="toc-text">i、移动拷贝和移动赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-mutable-mutex"><span class="toc-number">8.</span> <span class="toc-text">i、mutable mutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8D%95%E8%8E%B7-this-%E6%8C%87%E9%92%88"><span class="toc-number">9.</span> <span class="toc-text">i、lambda 表达式捕获 this 指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">10.</span> <span class="toc-text">i、优先队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-stdoptional"><span class="toc-number">11.</span> <span class="toc-text">i、std::optional</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#stdoptional-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">11.0.1.</span> <span class="toc-text">std::optional 的定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E5%92%8C%E7%94%A8%E6%B3%95"><span class="toc-number">11.0.2.</span> <span class="toc-text">主要功能和用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stdoptional-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">11.0.3.</span> <span class="toc-text">std::optional 的使用场景</span></a></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#i-%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">i、继承构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">12.0.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">12.0.2.</span> <span class="toc-text">继承构造函数的优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%99%90%E5%88%B6%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">12.0.3.</span> <span class="toc-text">继承构造函数的限制和注意事项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">12.0.4.</span> <span class="toc-text">实际应用示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8-bs_thread_pool-%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">12.0.5.</span> <span class="toc-text">在 BS_thread_pool 中的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-stdconditional_t-%E5%92%8C-stdis_void_v"><span class="toc-number">13.</span> <span class="toc-text">i、 std::conditional_t 和 std::is_void_v</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-if-constexpr"><span class="toc-number">14.</span> <span class="toc-text">i、if constexpr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%A6%81%E7%94%A8"><span class="toc-number">15.</span> <span class="toc-text">i、构造函数的禁用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-thread_local"><span class="toc-number">16.</span> <span class="toc-text">i、thread_local</span></a></li></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2024/10/22/%E7%B2%97%E8%AF%BB-BS-thread-pool-%E6%9C%AD%E8%AE%B0/" rel="bookmark" title="粗读 BS_thread_pool 札记">粗读 BS_thread_pool 札记</a></li><li><a href="/2024/10/22/thread/" rel="bookmark" title="thread">thread</a></li><li><a href="/2024/10/22/async/" rel="bookmark" title="async">async</a></li><li><a href="/2024/10/22/promise/" rel="bookmark" title="promise">promise</a></li><li><a href="/2024/10/22/future/" rel="bookmark" title="future">future</a></li><li><a href="/2024/10/22/packaged-task/" rel="bookmark" title="packaged_task">packaged_task</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Rick how" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Rick how</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">30</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">4</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hvdzIwNTE=" title="https:&#x2F;&#x2F;github.com&#x2F;how2051"><i class="ic i-github"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmNoZW5oYW9fcHVibGljQDE2My5jb20=" title="mailto:chenhao_public@163.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/10/21/%E3%80%8AGoogle-C-Style-Guide%E3%80%8Bnote/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/10/22/thread/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Rick how @ R1ck's Playground</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">286k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:20</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/10/22/粗读-BS-thread-pool-札记/",favicon:{show:"欢迎回来~",hide:"等你回来~"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->