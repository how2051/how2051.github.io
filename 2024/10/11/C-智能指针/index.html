<!-- build time:Sun Nov 03 2024 09:37:36 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="how" href="https://how2051.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="how" href="https://how2051.github.io/atom.xml"><link rel="alternate" type="application/json" title="how" href="https://how2051.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://how2051.github.io/2024/10/11/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"><title>C++ 智能指针 - C++ - 编程 | R1ck's Playground = how</title><meta name="generator" content="Hexo 7.0.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C++ 智能指针</h1><div class="meta"><span class="item" title="创建时间：2024-10-11 20:09:44"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-10-11T20:09:44+08:00">2024-10-11</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>15k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>13 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">R1ck's Playground</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="item" rel="index" title="分类于 编程"><span itemprop="name">编程</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%BC%96%E7%A8%8B/C/" itemprop="item" rel="index" title="分类于 C++"><span itemprop="name">C++</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://how2051.github.io/2024/10/11/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Rick how"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="how"></span><div class="body md" itemprop="articleBody"><p>智能指针是 C++ 中用于管理动态分配的对象生命周期的一种特殊指针。它们提供了自动内存管理和资源释放的机制，避免了手动调用 <code>delete</code> 来释放内存的麻烦和潜在的内存泄漏。</p><p>C++ 标准库提供了两种常用的智能指针： <code>std::shared_ptr</code> 和 <code>std::unique_ptr</code> 。<br>（其实还有 <code>std::weak_ptr</code> ，用于破解循环引用的问题）</p><ol><li><code>std::shared_ptr</code> ：它是一种共享所有权的智能指针。多个 <code>std::shared_ptr</code> 对象可以同时拥有同一个对象的所有权。它使用引用计数的方式来跟踪对象的引用次数。当最后一个 <code>std::shared_ptr</code> 对象超出作用域或被显式地设置为 <code>nullptr</code> ，引用计数变为零时，对象会自动销毁。这样可以确保对象在没有引用时被正确地释放，避免了内存泄漏。</li><li><code>std::unique_ptr</code> ：它是一种独占所有权的智能指针。一个 <code>std::unique_ptr</code> 对象拥有唯一的所有权，不能被其他智能指针共享。<mark>它使用了移动语义，因此具有很高的效率</mark>。当 <code>std::unique_ptr</code> 对象超出作用域时，或者通过 <code>std::move</code> 转移所有权时，对象会自动销毁。这样可以避免资源的重复释放和悬空指针的问题。</li></ol><p>智能指针的好处在于它们提供了自动资源管理，减少了手动管理内存的错误和复杂性。此外，它们还能帮助解决资源泄漏、悬空指针和内存安全等问题。</p><p>以下是使用智能指针的示例代码：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::shared_ptr</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; anotherSharedPtr = sharedPtr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::unique_ptr</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uniquePtr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这个示例中， <code>std::shared_ptr</code> 和 <code>std::unique_ptr</code> 能够自动管理动态分配的整数对象的生命周期。无需手动释放内存，当 <code>std::shared_ptr</code> 对象超出作用域时，引用计数减少；当 <code>std::unique_ptr</code> 对象超出作用域时，对象自动销毁。</p><h3 id="底层实现"><a class="anchor" href="#底层实现">#</a> 底层实现</h3><p>当我们创建智能指针 <code>shared_ptr</code> 指向一个对象的时候，其构造函数会分配一个空间创建一个管理对象 <code>manager object</code> ，这个管理对象是动态分配的，<strong>其包含了一个裸指针，指向我们要管理的对象，还包含了 <code>shared_ptr</code> 的引用计数和 <code>weak_ptr</code> 的引用计数</strong>。<br>一开始，当创建一个 <code>shared_ptr</code> 指向一个新创建的对象，显然，sp 的引用计数为 1，wp 的引用计数为 0，然后裸指针指向对象。<br>正如我们所经常听说的那样，当 sp 引用计数为 0 时，对象会销毁。<strong>这里多了一个不为大家所熟知的小细节，就是此时这个管理对象还不会释放，只有等 wp 也减为 0 的时候，才会释放这个管理对象</strong>。</p><h3 id="关于智能指针的注意事项"><a class="anchor" href="#关于智能指针的注意事项">#</a> 关于智能指针的注意事项</h3><p>在使用智能指针时，有一些注意事项需要注意：</p><ol><li>避免循环引用：如果使用 <code>std::shared_ptr</code> ，应避免形成循环引用，即两个或多个对象之间相互持有 <code>std::shared_ptr</code> ，导致引用计数无法降为零，从而导致内存泄漏。<strong>可以通过使用 <code>std::weak_ptr</code> 打破循环引用来解决这个问题。</strong></li><li><mark>不要使用裸指针和智能指针混合使用</mark>：尽量避免在代码中同时使用裸指针和智能指针，因为这可能会导致资源管理的混乱。如果需要使用裸指针，可以使用 <code>std::unique_ptr::get()</code> 方法获取裸指针。</li><li>使用合适的智能指针类型：根据情况选择合适的智能指针类型，例如使用 <code>std::shared_ptr</code> 进行共享所有权的管理，或者使用 <code>std::unique_ptr</code> 进行独占所有权的管理。选择适当的智能指针类型可以提高代码的可读性和安全性。</li><li>只能用智能指针指向用 new 分配的、能够用 delete 释放的对象上</li><li>尽可能地用 <code>make_shared</code> 去代替 new（但它也不是百利而无一害，见下文：<a href="https://how2051.github.io/2024/10/11/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#make_shared">make_shared</a>）</li></ol><h3 id="智能指针作为函数的入口参数和返回参数"><a class="anchor" href="#智能指针作为函数的入口参数和返回参数">#</a> 智能指针作为函数的入口参数和返回参数</h3><p>智能指针可以作为函数的参数和返回值类型，从而方便地管理动态分配的资源。</p><p>以下是一个示例：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数为智能指针类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processObject</span><span class="params">(std::shared_ptr&lt;<span class="type">int</span>&gt; ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针操作对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Object value: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回智能指针类型</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">createObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建动态分配的对象，并返回智能指针</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针作为函数参数</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    <span class="built_in">processObject</span>(sharedPtr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用智能指针作为函数返回值</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uniquePtr = <span class="built_in">createObject</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Object value: &quot;</span> &lt;&lt; *uniquePtr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这个示例中， <code>processObject</code> 函数接受一个 <code>std::shared_ptr&lt;int&gt;</code> 参数，用于处理动态分配的整数对象。 <code>createObject</code> 函数创建一个动态分配的整数对象，并返回一个 <code>std::unique_ptr&lt;int&gt;</code> 。<p></p><p>最后，再回答 <code>make_shared</code> 的作用和对象存放位置的问题。 <code>std::make_shared</code> 是一个模板函数，用于创建智能指针对象，它的作用是<mark>在一次内存分配中同时创建对象和管理对象的引用计数</mark>。由于对象和引用计数信息存储在一块连续的内存中，因此可以提高性能和内存利用率。</p><p>至于对象存放的位置， <code>std::make_shared</code> 创建的对象和引用计数信息通常存储在一块连续的内存块中，这个内存块位于堆上。这样的设计可以减少内存碎片化，并提高内存访问的效率。</p><h3 id="weak_ptr"><a class="anchor" href="#weak_ptr">#</a> weak_ptr</h3><p>1、初始化：<br>wp 的初始化默认是空的，不指向任何东西 —— 甚至不指向一个 manager object。<br>所以你只能通过从 <code>shared_ptr</code> 或现有的 <code>weak_ptr</code> 进行拷贝构造或复制构造然后将 <code>weak_ptr</code> 指向它：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Thing&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Thing)</span></span>;</span><br><span class="line"><span class="function">weak_ptr&lt;Thing&gt; <span class="title">wp1</span><span class="params">(sp)</span></span>; <span class="comment">// construct wp1 from a shared_ptr</span></span><br><span class="line">weak_ptr&lt;Thing&gt; wp2; <span class="comment">// an empty weak_ptr - points to nothing</span></span><br><span class="line">wp2 = sp; <span class="comment">// wp2 now points to the new Thing</span></span><br><span class="line"><span class="function">weak_ptr&lt;Thing&gt; <span class="title">wp3</span><span class="params">(wp2)</span></span>; <span class="comment">// construct wp3 from a weak_ptr</span></span><br><span class="line">weak_ptr&lt;Thing&gt; wp4</span><br><span class="line">wp4 = wp2; <span class="comment">// wp4 now points to the new Thing.</span></span><br></pre></td></tr></table></figure><p></p><p>2、引用<br><mark>你不能直接用 wp 去引用对象，而是通过一个 sp 来接住 <code>wp.lock()</code> 返回的内容</mark>。lock 函数会判断当前 wp 指向的对象是否还存在 / 有效，如果存在，该函数会返回一个该对象的 sp，如果不存在，则返回一个空的 sp：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Thing&gt; sp2 = wp2.<span class="built_in">lock</span>(); <span class="comment">// get shared_ptr from weak_ptr</span></span><br></pre></td></tr></table></figure><p></p><p>通常，我们有 3 种方式去引用一个 wp：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方法，通过 sp 和 lock，然后判断 sp 是否为空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_it</span><span class="params">(weak_ptr&lt;Thing&gt; wp)</span></span>&#123;</span><br><span class="line">    shared_ptr&lt;Thing&gt; sp = wp.<span class="built_in">lock</span>(); <span class="comment">// get shared_ptr from weak_ptr</span></span><br><span class="line">    <span class="keyword">if</span>(sp) &#123;</span><br><span class="line">        sp-&gt;<span class="built_in">defrangulate</span>(); <span class="comment">// tell the Thing to do something</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The Thing is gone!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法，利用 wp 的 expired 函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_it_there</span><span class="params">(weak_ptr&lt;Thing&gt; wp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(wp.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The Thing is gone!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种方式，利用 wp 构造一个 sp，然后捕获异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_it</span><span class="params">(weak_ptr&lt;Thing&gt; wp)</span></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Thing&gt; <span class="title">sp</span><span class="params">(wp)</span></span>; <span class="comment">// construct shared_ptr from weak_ptr</span></span><br><span class="line">    <span class="comment">// exception thrown if wp is expired, so if here, sp is good to go</span></span><br><span class="line">    sp-&gt;<span class="built_in">defrangulate</span>(); <span class="comment">// tell the Thing to do something</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">do_it</span>(wpx);</span><br><span class="line">&#125; <span class="built_in">catch</span>(bad_weak_ptr&amp;) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A Thing (or something else) has disappeared!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>3、特殊使用场景<br>wp 除了下文提到的<mark>解决循环引用</mark>的问题之外，还有一个特殊的使用场景就是获取对象的 this 指针。<br>当一个对象要通过 <code>shared_ptr</code> 的形式获取一个 this 指针以便实现自动的内存管理时，如果我们仅仅通过拷贝 this 指针来构造 sp 的话，由于 this 指针是个裸指针，于是又会生成一个新的管理对象来指向被管理的对象，于是现在有两个 manager object 了。那么最终就很可能造成内存重复释放的错误：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thing::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// we need to transmogrify this object</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Thing&gt; <span class="title">sp_for_this</span><span class="params">(<span class="keyword">this</span>)</span></span>; <span class="comment">// danger! a second manager object!</span></span><br><span class="line">    <span class="built_in">transmogrify</span>(sp_for_this);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//假设 Thing 对象本身就是用 sp 创建的，那么当其调用 foo 函数时，又将创建一个管理对象</span></span><br></pre></td></tr></table></figure><p></p><p>为了解决这个问题，需要借助 <code>std::enabled_shared_from_this</code> 来实现，是一个类模板，将 Thing 继承自它，然后再需要用到 this 指针的地方通过调用 <code>shared_from_this()</code> 这个函数来实现。</p><p><code>enabled_shared_from_this</code> 的底层逻辑大概就是在定义类时，类还有一个 wp 的成员变量指向负责管理该类对象的 manager object，然后每次我们调用 <code>shared_from_this</code> 的时候就是拿到 wp 所指向的这个 manager object 所指向的对象 —— 不会多生成一个管理对象。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span> : <span class="keyword">public</span> enable_shared_from_this&lt;Thing&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">defrangulate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thing::foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// we need to transmogrify this object</span></span><br><span class="line">    <span class="comment">// get a shared_ptr from the weak_ptr in this object</span></span><br><span class="line">    shared_ptr&lt;Thing&gt; sp_this = <span class="built_in">shared_from_this</span>();</span><br><span class="line">    <span class="built_in">transmogrify</span>(sp_this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transmogrify</span><span class="params">(shared_ptr&lt;Thing&gt; ptr)</span> </span>&#123;</span><br><span class="line">    ptr-&gt;<span class="built_in">defrangulate</span>();</span><br><span class="line">    <span class="comment">/* etc. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The following starts a manager object for the Thing and also</span></span><br><span class="line">    <span class="comment">// initializes the weak_ptr member that is now part of the Thing.</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Thing&gt; <span class="title">t1</span><span class="params">(<span class="keyword">new</span> Thing)</span></span>;</span><br><span class="line">    t1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="make_shared"><a class="anchor" href="#make_shared">#</a> make_shared</h3><p>当我们创建一个 sp 指向一个新 new 出来的对象时，一种语法是：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Thing&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Thing)</span></span>;</span><br></pre></td></tr></table></figure><br>在这种情况下，<mark>会触发两次内存分配</mark>，一次是调用 Thing 的构造函数，分配其内存，还有一次是调用 sp 的构造函数，分配其内存给一个管理对象。而两次内存分配会导致性能 / 效率的降低。<p></p><p>所以，为了优化这个问题，有了 <code>make_shared</code> 这个函数，用来一次分配足够的内存：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Thing&gt; <span class="title">p</span><span class="params">(make_shared&lt;Thing&gt;())</span></span>; <span class="comment">// only one allocation!</span></span><br></pre></td></tr></table></figure><br>在这种情况下，<mark>只会发生一次内存分配</mark>，效率提高。<p></p><p>这里有个小问题，为什么 <code>make_shared</code> 也需要传入一个模板参数 Thing 呢？是为了灵活性考虑，这样的话 <code>make_shared</code> <mark>生成的对象就可以是其他类型然后 cast 造型给 sp 使用</mark>。比如在继承关系中用于父类、子类的指针指向：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Base&gt; <span class="title">bp</span><span class="params">(make_shared&lt;Derived1&gt;())</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>最后，如果 Thing 的构造函数需要传递参数，在 make_shared 后面接着加上即可：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Thing&gt; <span class="title">p</span> <span class="params">(make_shared&lt;Thing&gt;(<span class="number">42</span>, <span class="string">&quot;I&#x27;m a Thing!&quot;</span>))</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>这里提一嘴，虽然说我们用 <code>make_shared</code> 可以优化效率，但是它也不是就完全没有缺点。根据前面 “底层实现” 提到的内容，如果我们用 <code>make_shared</code> 生成的内容，sp 已经减为 0 了，但是 wp 还大于 0，那么整块内存都不会被释放。</p><h3 id="循环引用"><a class="anchor" href="#循环引用">#</a> 循环引用</h3><p>循环引用是指两个或多个对象相互持有 <code>std::shared_ptr</code> ，导致它们之间的引用计数无法降为零，从而造成内存泄漏。当存在循环引用时，即使不再使用这些对象，它们所占用的内存也无法被释放，从而导致资源泄漏。</p><p>下面我们通过一个简单的示例来展示循环引用问题：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;  <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; bPtr;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; aPtr;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; aPtr = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; bPtr = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立循环引用</span></span><br><span class="line">    aPtr-&gt;bPtr = bPtr;</span><br><span class="line">    bPtr-&gt;aPtr = aPtr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在上述示例中，我们定义了两个类 <code>A</code> 和 <code>B</code> ，它们分别包含一个 <code>std::shared_ptr</code> 成员变量用于相互引用。在 <code>main</code> 函数中，我们创建了两个对象 <code>aPtr</code> 和 <code>bPtr</code> ，然后通过相互赋值建立了循环引用。</p><p>当程序结束时，这两个对象的析构函数并不会被调用，因为它们之间的循环引用导致引用计数无法降为零。这就造成了内存泄漏，因为这些对象所占用的内存无法被释放。</p><p>为了解决循环引用问题，C++ 提供了 <code>std::weak_ptr</code> 。 <code>std::weak_ptr</code> 是一种弱引用，它可以引用 <code>std::shared_ptr</code> 指向的对象，但并不会增加对象的引用计数。通过将其中一个指针使用 <code>std::weak_ptr</code> 来打破循环引用，从而实现对象的正确释放。</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//于是，只需要把上面的其中一个指针声明为weak_ptr即可</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;  <span class="comment">//Forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; bPtr;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// std::shared_ptr&lt;A&gt; aPtr;</span></span><br><span class="line">    std::weak_ptr&lt;A&gt; aPtr;  <span class="comment">//use weak ptr to break the loop</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        std::shared_ptr&lt;A&gt; aPtr = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">        std::shared_ptr&lt;B&gt; bPtr = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">        <span class="comment">// make it loop</span></span><br><span class="line">        aPtr-&gt;bPtr = bPtr;</span><br><span class="line">        bPtr-&gt;aPtr = aPtr;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;in while loop...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>std::weak_ptr</code> 并不能直接打破循环引用，而是通过辅助的机制来解决循环引用的问题。它并不增加引用计数，因此即使存在循环引用，对象的引用计数也会降为零，从而触发析构函数的调用。</p><p>在前面的示例中，当 <code>aPtr</code> 和 <code>bPtr</code> 的引用计数降为零时，它们的析构函数会被调用，从而释放它们所占用的内存。由于 <code>bPtr</code> 使用的是 <code>std::weak_ptr</code> ，它并不增加 <code>aPtr</code> 的引用计数，因此循环引用并不会阻止 <code>aPtr</code> 的析构。这样就避免了 <code>std::shared_ptr</code> 循环引用导致的内存泄漏问题。</p><p>因此，可以说 <code>std::weak_ptr</code> 并非直接打破循环引用，而是通过协助 <code>std::shared_ptr</code> 来实现循环引用的解决方案。它在不增加引用计数的前提下，提供了一种访问被 <code>std::shared_ptr</code> 管理的对象的方式，并且不会阻止对象的销毁。</p><h3 id="unique_ptr"><a class="anchor" href="#unique_ptr">#</a> unique_ptr</h3><p>它和 sp 其实差不多了，区别就是 ownership 的独占，which 通过禁用拷贝构造和赋值构造来实现，所以你不能拷贝或赋值一个 up 给另一个 up：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Thing&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> Thing)</span></span>; <span class="comment">// p1 owns the Thing</span></span><br><span class="line"><span class="function">unique_ptr&lt;Thing&gt; <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// error - copy construction is not allowed.</span></span><br><span class="line">unique_ptr&lt;Thing&gt; p3; <span class="comment">// an empty unique_ptr;</span></span><br><span class="line">p3 = p1; <span class="comment">// error, copy assignment is not allowed</span></span><br></pre></td></tr></table></figure><p></p><p>由于禁用拷贝构造，所以如果要把 up 作为函数参数进行传参时，只能 pass by reference，不能 pass by value。</p><p>1、所有权转移<br><strong>而由于 up 对于对象的所有权是独占的，所以有时需要转移所有权，这依赖于移动语义，使用移动构造和移动赋值函数。</strong></p><p>其中，我们知道，函数的返回值是右值，所以 up 的这种移动语义可以用于我们在函数中返回一个局部的 up 给外层调用该函数的 up，实现移动：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create a Thing and return a unique_ptr to it:</span></span><br><span class="line"><span class="function">unique_ptr&lt;Thing&gt; <span class="title">create_Thing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;Thing&gt; <span class="title">local_ptr</span><span class="params">(<span class="keyword">new</span> Thing)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> local_ptr; <span class="comment">// local_ptr will surrender ownership</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;Thing&gt; <span class="title">p1</span><span class="params">(create_Thing())</span></span>; <span class="comment">// move ctor from returned rvalue</span></span><br><span class="line">    <span class="comment">// p1 now owns the Thing</span></span><br><span class="line">    unique_ptr&lt;Thing&gt; p2; <span class="comment">// default ctor&#x27;d; owns nothing</span></span><br><span class="line">    p2 = <span class="built_in">create_Thing</span>(); <span class="comment">// move assignment from returned rvalue</span></span><br><span class="line">    <span class="comment">// p2 now owns the second Thing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>2、所有权的显式转移<br>通过 <code>std::move()</code> 函数来显式地进行所有权的转移：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Thing&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Thing)</span></span>; <span class="comment">// p1 owns the Thing</span></span><br><span class="line">unique_ptr&lt;Thing&gt; p2; <span class="comment">// p2 owns nothing</span></span><br><span class="line"><span class="comment">// invoke move assignment explicitly</span></span><br><span class="line">p2 = std::<span class="built_in">move</span>(p1); <span class="comment">// now p2 owns it, p1 owns nothing</span></span><br><span class="line"><span class="comment">// invoke move construction explicitly</span></span><br><span class="line"><span class="function">unique_ptr&lt;Thing&gt; <span class="title">p3</span><span class="params">(std::move(p2))</span></span>; <span class="comment">// now p3 owns it, p2 and p1 own nothing</span></span><br></pre></td></tr></table></figure><p></p><p>另外，前面在讲 sp 的时候讲到了有个函数 <code>make_shared</code> ，而 C++11 居然没有相对应的 <code>make_unique</code> ，直到 C++14 的时候才引入了 <code>make_unique</code> 函数。不过， <code>make_unique</code> 不会有性能上的提升，因为 up 并不会分配管理对象，所以没有额外的内存分配，不会有两次内存分配，就不会有性能低的问题。—— 可能这就是为什么 C++11 引入了 <code>make_shared</code> 却没有同时引入 <code>make_unique</code> 的原因吧。</p><h3 id="shared_ptr"><a class="anchor" href="#shared_ptr">#</a> shared_ptr</h3><p>Shared pointer，a class template：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">shared_ptr</span>;</span><br></pre></td></tr></table></figure><p></p><p>简单来说，share pointer 具备引用计数、自动释放的特点。多个  <code>shared_ptr</code>  指向同一块内存时，每多一个指针指向该内存，引用数相应自增，反之亦然。当一块内存的  <code>shared_ptr</code>  引用数减少为 0 时，自动释放该内存。</p><p>即，我们可以通过智能指针来申请动态内存，其会有一个相应的引用计数（申请时初始值为 1，表明当前这个  <code>shared_ptr</code>  指向该内存）。每当有新的智能指针指向该内存时，引用计数自增。</p><p><span class="exturl" data-url="aHR0cHM6Ly9jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9tZW1vcnkvc2hhcmVkX3B0ci8=">https://cplusplus.com/reference/memory/shared_ptr/</span></p><p><strong>智能指针的创建：</strong></p><p>空智能指针：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1;	<span class="comment">//指向 int 类型的智能指针，此时不传入任何实参，为空指针</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;	<span class="comment">//传入空指针 nullptr</span></span><br><span class="line"><span class="comment">//空指针的引用计数为 0，此时并未指向任何内存，合情合理</span></span><br></pre></td></tr></table></figure><p></p><p>非空智能指针：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;	<span class="comment">//指向一个值为 3 的 int 型的内存</span></span><br><span class="line"><span class="comment">//此时引用计数为 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另外，也可以通过 C++11 提供的模板函数来初始化智能指针</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p4 = std::<span class="built_in">make_share</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p></p><p>构造函数（拷贝构造和移动构造）：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(p4)</span></span>;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p6 = p5;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动构造</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(std::move(p6))</span></span>;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p8 = std::<span class="built_in">move</span>(p7);</span><br></pre></td></tr></table></figure><p></p><p><strong>成员方法：</strong></p><ul><li><p><code>swap()</code><br>交换两个相同类型  <code>shared_ptr</code>  的内容</p></li><li><p><code>reset()</code><br>当该函数没有传入实参时，作用是<mark>将当前  <code>shared_ptr</code>  所指内存的引用计数减 1</mark>，同时将当前指针对象重置为一个空指针；</p></li></ul><p>当该函数传入一个实参（一个新申请的堆空间）时，则当前指针对象会指向该新申请的堆空间且引用计数初始值为 1，同时，原指向的堆空间（如果有）的引用计数自然而然减 1，如果减 1 后为 0，则释放该内存</p><ul><li><p><code>get()</code><br>获得  <code>shared_ptr</code>  对象内部包含的普通指针</p></li><li><p><code>use_count()</code><br>返回当前智能指针所指向内存的引用计数值，即所有指向该内存的智能指针的数量</p></li><li><p><code>unique()</code><br>判断当前智能指针指向的堆内存，是否不再有其他  <code>shared_ptr</code>  指向它</p></li></ul><p><strong>参考链接：</strong><br><span class="exturl" data-url="aHR0cHM6Ly9jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9tZW1vcnkvc2hhcmVkX3B0ci9yZXNldC8=">https://cplusplus.com/reference/memory/shared_ptr/reset/</span><br><span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC92aWV3Lzc4OTguaHRtbA==">http://c.biancheng.net/view/7898.html</span><br><span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC92aWV3LzQzMC5odG1s">http://c.biancheng.net/view/430.html</span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZmX2dvZ28vYXJ0aWNsZS9kZXRhaWxzLzEyMzUxMjQ4Mg==">https://blog.csdn.net/ff_gogo/article/details/123512482</span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZHJlYW0zOTcvcC8xNDYyMDMyNC5odG1s">https://www.cnblogs.com/dream397/p/14620324.html</span></p><p><strong>实际应用：</strong><br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">m_dds_ctx.<span class="built_in">reset</span>(<span class="keyword">new</span> minieye::DDS::<span class="built_in">Context</span>(FLAGS_config_json_radar, <span class="literal">true</span>));</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (radar_topic != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;minieye::DDS::Reader&gt; <span class="title">r</span><span class="params">(<span class="keyword">new</span> minieye::DDS::Reader(</span></span></span><br><span class="line"><span class="params"><span class="function">        m_dds_ctx.get(), radar_topic-&gt;topic, OnRecvDDS, <span class="keyword">this</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    m_readers = r;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p></p><h3 id="deleter-删除器"><a class="anchor" href="#deleter-删除器">#</a> deleter 删除器</h3><p>对于自定义的类，我们知道存在构造函数和析构函数，析构函数能够在对象销毁时被自动调用，结合智能指针则能够实现自动管理，让其在引用计数减为 0 时自动调用析构函数释放资源。</p><p>但是，对于内置的类型，比如 int、float 这种，并不存在任何析构函数，所以无论我们是否使用智能指针，我们都不能很好地调用所谓的 “析构函数” 来释放资源。比如：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; num&#123;<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>)&#125;;</span><br></pre></td></tr></table></figure><p></p><p>针对这种情况，我们需要用到 deleter。</p><p>在智能指针中，可以指定一个删除器，用于在引用计数减为 0 时调用该删除器，进行资源的释放。以 <code>shared_ptr</code> 举例，它的其中两种构造函数如下：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span> <span class="title class_">D</span>&gt; <span class="built_in">shared_ptr</span>(U* p, D del);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">D</span>&gt; <span class="built_in">shared_ptr</span>(<span class="type">nullptr_t</span> p, D del);</span><br><span class="line">#其中 del 是一个删除器</span><br></pre></td></tr></table></figure><p></p><p><code>deleter</code> 可以是以下类型之一：</p><ol><li>函数指针：指向一个函数，该函数会在智能指针的资源需要释放时被调用。</li><li>函数对象（Functor）：是一个类对象，重载了函数调用运算符 <code>operator()</code> ，可以像函数一样调用。</li><li>Lambda 表达式：一种匿名函数，可以用作智能指针的 <code>deleter</code> 。</li></ol><p>于是就有了这种智能指针的构造方式：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Lambda 表达式作为 deleter 的 std::shared_ptr</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">sharedPtr</span><span class="params">(<span class="keyword">new</span> MyClass(<span class="number">24</span>), [](MyClass* ptr) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; <span class="string">&quot;Lambda deleter is called&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">delete</span> ptr;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>整体示例代码：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Custom deleter function declaration</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_deleter</span><span class="params">(<span class="type">int</span>* ptr)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Deleting integer pointer with value: &quot;</span> &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Delete Successful.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int type smart pointer object</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr &#123;<span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">5</span>&#125;, my_deleter&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>大概是这样。<p></p><p>这里需要注意的是，我们的 <code>shared_ptr</code> 的构造函数存在几种形式：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">( Y* ptr )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y, <span class="keyword">class</span> Deleter &gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">( Y* ptr, Deleter d )</span></span>;</span><br></pre></td></tr></table></figure><br>对于前者，当引用计数值为 0 时会使用 <code>delete ptr</code> 或 <code>delete[] ptr</code> ，具体取决于 <code>T</code> 是否为数组类型。而对于后者，则是通过传入一个用户自定义的删除器，在引用计数值为 0 自动调用。详细信息见：<span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL21lbW9yeS9zaGFyZWRfcHRyL3NoYXJlZF9wdHI=">shared_ptr</span><p></p><p>但是由此又似乎会得出结论，哪怕我们没有指定删除器，利用原本的 delete 语法也能处理基本类型嘛？再者，当使用智能指针管理基础类型时，真的不能有效释放内存吗？sus</p><h3 id="qa"><a class="anchor" href="#qa">#</a> Q&amp;A</h3><blockquote><p>智能指针如何判空？</p></blockquote><p>我们知道，对于裸指针，我们可以直接在 if 条件语句中将其用作条件进行判空，如：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* rp = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rp) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同样的，对于智能指针，也能这么操作。<p></p><p>智能指针可以使用 <code>operator bool()</code> 或 <code>get()</code> 方法来进行空指针判断。以下是两种常用的方法：</p><ol><li><strong>使用 <code>operator bool()</code> ：</strong></li></ol><p><code>std::shared_ptr</code> 和 <code>std::unique_ptr</code> 都定义了 <code>operator bool()</code> ，可以用于将智能指针直接用于布尔上下文中进行判空。</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">    <span class="comment">// 指针不为空</span></span><br><span class="line">    <span class="comment">// 执行代码...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 指针为空</span></span><br><span class="line">    <span class="comment">// 执行其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ol start="2"><li><strong>使用 <code>get()</code> 方法：</strong></li></ol><p><code>get()</code> 方法返回底层裸指针，你可以将其与 <code>nullptr</code> 比较来进行判空。</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptr.<span class="built_in">get</span>() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 指针不为空</span></span><br><span class="line">    <span class="comment">// 执行代码...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 指针为空</span></span><br><span class="line">    <span class="comment">// 执行其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>不过第二种方法有点没必要，好好的智能指针不用，还把它转化成裸指针，何苦呢</p><p>另外，这里的 <code>operator bool()</code> 是操作符重载，具体地：</p><p><code>operator bool()</code> 是一个类型转换运算符，用于将类对象转换为布尔值。在 C++ 中，运算符重载允许程序员自定义类对象在特定上下文中的操作行为，而 <code>operator bool()</code> 是其中一种常见的运算符重载。</p><p>运算符重载的语法如下：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 类型转换运算符的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回用于将对象转换为布尔值的逻辑表达式</span></span><br><span class="line">        <span class="comment">// 返回 true 表示对象非空，返回 false 表示对象为空</span></span><br><span class="line">        <span class="keyword">return</span> someCondition;  <span class="comment">// 替换为实际的逻辑表达式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>在上述示例中， <code>operator bool()</code> 被定义为将 <code>MyClass</code> 类的对象转换为布尔值。注意其中的 <code>explicit</code> 关键字，它表示这个转换是显式的，防止隐式转换。</p><p>对于智能指针类（如 <code>std::shared_ptr</code> 和 <code>std::unique_ptr</code> ）， <code>operator bool()</code> 的实现通常是检查底层指针是否为 <code>nullptr</code> 。这样，当智能指针指向有效对象时，转换结果为 <code>true</code> ，指向空对象时，转换结果为 <code>false</code> 。这种设计使得智能指针在条件语句中的使用更加自然，就像原始指针一样。</p><p>以下是智能指针 <code>operator bool()</code> 的典型实现：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 类型转换运算符的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* ptr;  <span class="comment">// 以 int* 为例，实际上可能是其他类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>这使得你可以像下面这样使用智能指针：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr ptr = ...;  <span class="comment">// 通过某种方式初始化</span></span><br><span class="line"><span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">    <span class="comment">// 智能指针不为空，执行代码...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 智能指针为空，执行其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种运算符重载的使用，使得在条件语句中判空更加直观，提高了代码的可读性。<p></p><h3 id="相关阅读"><a class="anchor" href="#相关阅读">#</a> 相关阅读</h3><p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA2MTYzNC9ob3ctZG8taS1rbm93LXdoby1ob2xkcy10aGUtc2hhcmVkLXB0cg==">stack overflow：如何判断我的 shared_ptr 被谁持有？</span></p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-10-22 11:06:00" itemprop="dateModified" datetime="2024-10-22T11:06:00+08:00">2024-10-22</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝杯咖啡吧~</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Rick how 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Rick how 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Rick how <i class="ic i-at"><em>@</em></i>how</li><li class="link"><strong>本文链接：</strong> <a href="https://how2051.github.io/2024/10/11/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="C++ 智能指针">https://how2051.github.io/2024/10/11/C-智能指针/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/10/11/C-17-%E6%96%B0%E7%89%B9%E6%80%A7/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;ooo.0x0.ooo&#x2F;2023&#x2F;12&#x2F;08&#x2F;OAE0e6.jpg" title="C++17 新特性"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>C++17 新特性</h3></a></div><div class="item right"><a href="/2024/10/12/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;ooo.0x0.ooo&#x2F;2023&#x2F;12&#x2F;08&#x2F;OAE0e6.jpg" title="C++ 多线程"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>C++ 多线程</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.</span> <span class="toc-text">关于智能指针的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%8F%82%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">智能指针作为函数的入口参数和返回参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak_ptr"><span class="toc-number">4.</span> <span class="toc-text">weak_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#make_shared"><span class="toc-number">5.</span> <span class="toc-text">make_shared</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">循环引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique_ptr"><span class="toc-number">7.</span> <span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared_ptr"><span class="toc-number">8.</span> <span class="toc-text">shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deleter-%E5%88%A0%E9%99%A4%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">deleter 删除器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#qa"><span class="toc-number">10.</span> <span class="toc-text">Q&amp;A</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB"><span class="toc-number">11.</span> <span class="toc-text">相关阅读</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2024/10/11/C-17-%E6%96%B0%E7%89%B9%E6%80%A7/" rel="bookmark" title="C++17 新特性">C++17 新特性</a></li><li class="active"><a href="/2024/10/11/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" rel="bookmark" title="C++ 智能指针">C++ 智能指针</a></li><li><a href="/2024/10/12/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="bookmark" title="C++ 多线程">C++ 多线程</a></li><li><a href="/2024/10/12/C-%E8%B8%A9%E6%B0%B4%E6%B4%BC/" rel="bookmark" title="C++ 踩水洼">C++ 踩水洼</a></li><li><a href="/2024/10/12/C-%E9%A2%84%E5%88%B6%E8%8F%9C/" rel="bookmark" title="C++ 预制菜">C++ 预制菜</a></li><li><a href="/2024/10/12/C-%E5%BA%93%E5%87%BD%E6%95%B0/" rel="bookmark" title="C++ 库函数">C++ 库函数</a></li><li><a href="/2024/10/18/C-%E7%9A%84%E5%B8%B8%E9%87%8F/" rel="bookmark" title="C++ 的常量">C++ 的常量</a></li><li><a href="/2024/10/18/C-%E7%9A%84%E5%A4%9A%E6%80%81/" rel="bookmark" title="C++ 的多态">C++ 的多态</a></li><li><a href="/2024/10/18/C-%E7%9A%84%E7%BB%A7%E6%89%BF/" rel="bookmark" title="C++ 的继承">C++ 的继承</a></li><li><a href="/2024/10/18/C-%E7%9A%84%E6%B5%81/" rel="bookmark" title="C++ 的流">C++ 的流</a></li><li><a href="/2024/10/18/C-%E7%B1%BB%E4%B8%8E%E6%A8%A1%E6%9D%BF/" rel="bookmark" title="C++ 类与模板">C++ 类与模板</a></li><li><a href="/2024/10/18/C-%E4%BB%80%E9%94%A6/" rel="bookmark" title="C++ 什锦">C++ 什锦</a></li><li><a href="/2024/10/18/C-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/" rel="bookmark" title="C++ 文件读写">C++ 文件读写</a></li><li><a href="/2024/10/18/C-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/" rel="bookmark" title="C++ 异常机制">C++ 异常机制</a></li><li><a href="/2024/10/18/extern-C/" rel="bookmark" title="extern C">extern C</a></li><li><a href="/2024/10/18/lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="bookmark" title="lambda 表达式">lambda 表达式</a></li><li><a href="/2024/10/21/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/" rel="bookmark" title="可变参数模板">可变参数模板</a></li><li><a href="/2024/10/21/%E3%80%8AGoogle-C-Style-Guide%E3%80%8Bnote/" rel="bookmark" title="《Google C++ Style Guide》note">《Google C++ Style Guide》note</a></li><li><a href="/2024/10/22/%E7%B2%97%E8%AF%BB-BS-thread-pool-%E6%9C%AD%E8%AE%B0/" rel="bookmark" title="粗读 BS_thread_pool 札记">粗读 BS_thread_pool 札记</a></li><li><a href="/2024/10/22/thread/" rel="bookmark" title="thread">thread</a></li><li><a href="/2024/10/22/async/" rel="bookmark" title="async">async</a></li><li><a href="/2024/10/22/promise/" rel="bookmark" title="promise">promise</a></li><li><a href="/2024/10/22/future/" rel="bookmark" title="future">future</a></li><li><a href="/2024/10/22/packaged-task/" rel="bookmark" title="packaged_task">packaged_task</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Rick how" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Rick how</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">30</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">4</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hvdzIwNTE=" title="https:&#x2F;&#x2F;github.com&#x2F;how2051"><i class="ic i-github"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmNoZW5oYW9fcHVibGljQDE2My5jb20=" title="mailto:chenhao_public@163.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/10/11/C-17-%E6%96%B0%E7%89%B9%E6%80%A7/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/10/12/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Rick how @ R1ck's Playground</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">286k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:20</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/10/11/C-智能指针/",favicon:{show:"欢迎回来~",hide:"等你回来~"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->