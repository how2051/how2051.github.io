<!-- build time:Sun Nov 03 2024 13:22:29 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="R1ck's Playground" href="https://how2051.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="R1ck's Playground" href="https://how2051.github.io/atom.xml"><link rel="alternate" type="application/json" title="R1ck's Playground" href="https://how2051.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="回溯"><link rel="canonical" href="https://how2051.github.io/2024/11/03/007-%E4%BA%8C%E5%8F%89%E6%A0%91/"><title>007_二叉树 - Leetcode - 编程 | R1ck's Playground</title><meta name="generator" content="Hexo 7.0.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">007_二叉树</h1><div class="meta"><span class="item" title="创建时间：2024-11-03 09:32:31"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-11-03T09:32:31+08:00">2024-11-03</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>42k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>39 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">R1ck's Playground</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li><li class="item" data-background-image="https://ooo.0x0.ooo/2023/12/08/OAE0e6.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="item" rel="index" title="分类于 编程"><span itemprop="name">编程</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%BC%96%E7%A8%8B/Leetcode/" itemprop="item" rel="index" title="分类于 Leetcode"><span itemprop="name">Leetcode</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://how2051.github.io/2024/11/03/007-%E4%BA%8C%E5%8F%89%E6%A0%91/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Rick"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="R1ck's Playground"></span><div class="body md" itemprop="articleBody"><h3 id="一-理论基础"><a class="anchor" href="#一-理论基础">#</a> 一、理论基础</h3><p>要了解二叉树的几种类型 / 定义；</p><p>要熟悉几种遍历方式：</p><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><p>见 [[二叉树_0.png]]、[[二叉树_1.png]]</p><h4 id="11-递归法"><a class="anchor" href="#11-递归法">#</a> 1.1 递归法</h4><h5 id="i-递归法前序遍历"><a class="anchor" href="#i-递归法前序遍历">#</a> i、<strong>递归法前序遍历</strong>：</h5><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="i-递归法中序遍历"><a class="anchor" href="#i-递归法中序遍历">#</a> i、<strong>递归法中序遍历</strong>：</h5><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="i-递归法后序遍历"><a class="anchor" href="#i-递归法后序遍历">#</a> i、<strong>递归法后序遍历</strong>：</h5><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="12-迭代法"><a class="anchor" href="#12-迭代法">#</a> 1.2 迭代法</h4><h5 id="i-迭代法前序遍历"><a class="anchor" href="#i-迭代法前序遍历">#</a> i、<strong>迭代法前序遍历</strong>：</h5><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">nullptr</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* cur = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        ret.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right) st.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left) st.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>前序遍历顺序是 “中左右”，但是由于栈的性质是先进后出，所以这里 push 时要变成 “右左” 的顺序。（这样的话，pop 的时候才能先左后右。注意这里，我们的左右是相对于 stack 而言的，而 cur-val 是 push 进 vector 里面的。）<p></p><h5 id="i-迭代法中序遍历"><a class="anchor" href="#i-迭代法中序遍历">#</a> i、<strong>迭代法中序遍历</strong>：</h5><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>) &#123; <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">            st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">            cur = cur-&gt;left;  <span class="comment">// 左</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = st.<span class="built_in">top</span>(); <span class="comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 中</span></span><br><span class="line">            cur = cur-&gt;right;  <span class="comment">//右</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意这里，迭代法对于中序遍历的写法在框架上和前序 / 后序有所差异，并不是简单调换节点入栈顺序就可以的。<br>这是因为，前序遍历的顺序是 “中左右”，先访问的元素是中间节点，要处理的元素也是中间节点，所以才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong><p></p><h5 id="i-迭代法后序遍历"><a class="anchor" href="#i-迭代法后序遍历">#</a> i、<strong>迭代法后序遍历</strong>：</h5><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">nullptr</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* cur = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        ret.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left) st.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right) st.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">    &#125; <span class="built_in">reverse</span>(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里还得 reverse 翻转一下，hmmm...<br>后序遍历的顺序是 “左右中”，我们这里先是 “中左右”，经过 stack 的性质，变成了 “中右左”，最后我们再整体对 vector 进行翻转，成为 “左右中”。<p></p><h4 id="13-统一版迭代法"><a class="anchor" href="#13-统一版迭代法">#</a> 1.3 统一版迭代法</h4><p>如果想要把迭代法的三种遍历顺序都统一成一种形式，则有：</p><h5 id="i-迭代法统一版前序遍历"><a class="anchor" href="#i-迭代法统一版前序遍历">#</a> i、迭代法统一版前序遍历：</h5><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">nullptr</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">                st.<span class="built_in">push</span>(node);                         <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在这里，向栈中压入 nullptr 的目的是为了标记前一个元素已经被访问过，需要将其压入的 vector 中了。<p></p><p>具体地，下面是一个简化的流程，帮助理解 <code>nullptr</code> 的作用：</p><ul><li><p>假设有一个节点结构如下：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line"> / \</span><br><span class="line">B   C</span><br></pre></td></tr></table></figure><p></p></li><li><p>遍历开始时，将 A 压入栈，然后进入循环。</p></li><li><p>当处理 A 时，将 C（右子树）和 B（左子树）压入栈，接着压入 A 本身和 <code>nullptr</code> ：</p><ul><li>栈内容： <code>[C, B, A, nullptr]</code></li></ul></li><li><p>处理 A，弹出 A 并检查：</p><ul><li>弹出 <code>nullptr</code> ，然后弹出 A，添加 A 的值到结果。</li></ul></li><li><p>现在处理 B：</p><ul><li>将 B 压入栈时，栈会包含： <code>[C, B, nullptr]</code></li><li>处理 B，添加 B 的值到结果，然后处理其子节点（如果有）。</li></ul></li></ul><p>这里，由于我们前序遍历的顺序是 “中左右”，根据栈的先进先出的特性，我们需要以 “右左中” 的顺序入栈。<br>而如果以此顺序入栈，那么栈顶元素为 “中”，如果再对其进行 “右左中” 处理，则无限循环了。此时我们不应该对其进行进一步地访问，而是应该将其值进行存储了。所以 nullptr 的作用就是为了标记它的这种状态。</p><h5 id="i-迭代法统一版中序遍历"><a class="anchor" href="#i-迭代法统一版中序遍历">#</a> i、迭代法统一版中序遍历：</h5><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">nullptr</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                st.<span class="built_in">push</span>(node);                         <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里要注意，我们的 nullptr 是用来标记 “中” 节点的，所以要跟着 node 一起移动顺序。下面的后序遍历同理。<p></p><h5 id="i-迭代法统一版后序遍历"><a class="anchor" href="#i-迭代法统一版后序遍历">#</a> i、迭代法统一版后序遍历：</h5><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">nullptr</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(node);                         <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h4 id="20-层序遍历"><a class="anchor" href="#20-层序遍历">#</a> 2.0 层序遍历</h4><p>维护一个队列，利用其先进先出的特性，访问当前层的数据，同时，将下一层的数据压入到队列尾端，等待下一次遍历。<br>那么，每次循环需要通过获取队列长度来判断每层循环的次数（因为我们在遍历当前层时还会不断将下一层的数据入栈）<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">    <span class="keyword">if</span>(root) que.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; layer;</span><br><span class="line">        <span class="type">int</span> layer_size = que.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; layer_size; ++i) &#123;  <span class="comment">// 这里要使用固定的size，不能在这里输入 que.size()，因为它实时变化</span></span><br><span class="line">            TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            layer.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125; ret.<span class="built_in">push_back</span>(layer);</span><br><span class="line">    &#125; <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="30-其他"><a class="anchor" href="#30-其他">#</a> 3.0 其他</h4><h5 id="i-满二叉树"><a class="anchor" href="#i-满二叉树">#</a> i、满二叉树</h5><p>对于深度为 (n) 的满二叉树，节点的总数可以用以下公式计算：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>N</mi><mo>=</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N = 2^{n+1} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.947438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.864108em"><span style="top:-3.113em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></span></p><p>其中，</p><ul><li><strong>深度 (n)</strong> 指的是从根节点到最深叶子节点的最长路径上的边的数量。</li><li><strong>满二叉树</strong> 是一种每个节点都有两个子节点的二叉树，除了最深层的叶子节点外，所有层的节点数都达到了最大。</li></ul><p>则有：</p><ul><li>当 n = 0（树的深度为 0），节点总数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mn>0</mn><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{0+1} - 1 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>。</li><li>当 n = 1（树的深度为 1），节点总数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mn>1</mn><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">2^{1+1} - 1 = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span></span></span></span>。</li><li>当 n = 2（树的深度为 2），节点总数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mn>2</mn><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">2^{2+1} - 1 = 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">7</span></span></span></span>。</li></ul><p>在实际计算中，我们可以用移位操作代替指数运算，则有 <code>N = (2 &lt;&lt; n) - 1</code></p><h3 id="二-题目实践"><a class="anchor" href="#二-题目实践">#</a> 二、题目实践</h3><h4 id="1-144-二叉树的前序遍历"><a class="anchor" href="#1-144-二叉树的前序遍历">#</a> 1、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wcmVvcmRlci10cmF2ZXJzYWwv">144. 二叉树的前序遍历</span></h4><p>见上文理论基础部分；</p><h4 id="2-94-二叉树的中序遍历"><a class="anchor" href="#2-94-二叉树的中序遍历">#</a> 2、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1pbm9yZGVyLXRyYXZlcnNhbC8=">94. 二叉树的中序遍历</span></h4><p>见上文理论基础部分；</p><h4 id="3-145-二叉树的后序遍历"><a class="anchor" href="#3-145-二叉树的后序遍历">#</a> 3、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wb3N0b3JkZXItdHJhdmVyc2FsLw==">145. 二叉树的后序遍历</span></h4><p>见上文理论基础部分；</p><h4 id="4-102-二叉树的层序遍历"><a class="anchor" href="#4-102-二叉树的层序遍历">#</a> 4、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwv">102. 二叉树的层序遍历</span></h4><p>见上文理论基础部分；</p><h4 id="5-226-翻转二叉树"><a class="anchor" href="#5-226-翻转二叉树">#</a> 5、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnZlcnQtYmluYXJ5LXRyZWUv">226. 翻转二叉树</span></h4><ol><li><p>思路 1：<br>递归法，一想就会，一写就对，没啥难度：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li><li><p>思路 2：<br>层序遍历。逐层逐个遍历节点，对每个节点的左右子节点进行翻转。<br>这里需要注意的是，我们并不需要记录每一层的元素的数量，因为我们不 care：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(node-&gt;left, node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li></ol><h4 id="6-101-对称二叉树"><a class="anchor" href="#6-101-对称二叉树">#</a> 6、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zeW1tZXRyaWMtdHJlZS8=">101. 对称二叉树</span></h4><p>一上来想到的思路是层序遍历，把每一层的元素压入一个 vector，然后判断这个 vector 是否对称：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isVectorSymmetric</span><span class="params">(vector&lt;TreeNode*&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = vec.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; ++i, --j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[i] &amp;&amp; vec[j] &amp;&amp; vec[i]-&gt;val != vec[j]-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((!vec[i] &amp;&amp; vec[j]) || (vec[i] &amp;&amp; !vec[j])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> layer_size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;TreeNode*&gt; layer;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; layer_size; ++i) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                layer.<span class="built_in">push_back</span>(node-&gt;left);</span><br><span class="line">                layer.<span class="built_in">push_back</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isVectorSymmetric</span>(layer)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><ol start="2"><li><p>思路 2：<br>在层序遍历的基础之上，其实我们不需要每次把一整层的元素拿来遍历判断是否对称。<br>我们利用 “递归” 思想，只需要判断当前左右两个节点是否相等即可，然后在把当前两个节点的子节点压入队列进行下一轮比较，在入队时，“左左” 对应 “右右”，“左右” 对应 “右左”。其实算是迭代法，不能算是层序遍历了：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* left = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* right = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!left &amp;&amp; !right) &#123;  <span class="comment">// 左右皆空，此时说明是对称的</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左右一个节点不为空，或者都不为空但数值不相同，返回false</span></span><br><span class="line">            <span class="keyword">if</span>((!left || !right || (left-&gt;val != right-&gt;val))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            que.<span class="built_in">push</span>(left-&gt;left);</span><br><span class="line">            que.<span class="built_in">push</span>(right-&gt;right);</span><br><span class="line">            que.<span class="built_in">push</span>(left-&gt;right);</span><br><span class="line">            que.<span class="built_in">push</span>(right-&gt;left);</span><br><span class="line">        &#125; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li><li><p>思路 3：<br>那么，既然思路 3 说是递归思想了，那我们自然而然可以用递归法来做这道题：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!left &amp;&amp; !right) &#123;  <span class="comment">// 左右皆空，此时说明是对称的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左右一个节点不为空，或者都不为空但数值不相同，返回false</span></span><br><span class="line">        <span class="keyword">if</span>((!left || !right || (left-&gt;val != right-&gt;val))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);</span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> (outside &amp;&amp; inside);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li></ol><h4 id="7-104-二叉树的最大深度"><a class="anchor" href="#7-104-二叉树的最大深度">#</a> 7、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">104. 二叉树的最大深度</span></h4><ol><li><p>思路 1：<br>这道题一上来我的第一反应还是层序遍历（真好用嘿嘿嘿），逐层遍历，但是不 care 每一层有什么元素，每遍历一层，深度加一，最后返回深度即可：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> layer_size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; layer_size; ++i) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125; ++depth;</span><br><span class="line">        &#125; <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li><li><p>思路 2：<br>另一种思路就是递归，当前节点的最大深度等于左右子节点的最大深度 + 1：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getdepth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftdepth = <span class="built_in">getdepth</span>(node-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightdepth = <span class="built_in">getdepth</span>(node-&gt;right);     <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth); <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getdepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li></ol><h4 id="8-559-n-叉树的最大深度"><a class="anchor" href="#8-559-n-叉树的最大深度">#</a> 8、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLW4tYXJ5LXRyZWUv">559. N 叉树的最大深度</span></h4><p>在上一题的基础之上来做这道题，就很简单了：</p><ol><li><p>思路 1：<br>还是层序遍历，和上一题的唯一区别就是我们在处理节点的子节点时，需要遍历 children 里面的所有子节点：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> layer_size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; layer_size; ++i) &#123;</span><br><span class="line">                Node* node = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(Node* child : node-&gt;children) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(child) que.<span class="built_in">push</span>(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; ++depth;</span><br><span class="line">        &#125; <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li><li><p>思路 2：<br>递归。这里其实思路和上一题一致，只不过这里简化了递归的写法，合并在同一个函数，看上去可能有点抽象：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            depth = <span class="built_in">max</span>(depth, <span class="built_in">maxDepth</span>(root-&gt;children[i]));</span><br><span class="line">        &#125; <span class="keyword">return</span> depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li></ol><h4 id="9-111-二叉树的最小深度"><a class="anchor" href="#9-111-二叉树的最小深度">#</a> 9、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">111. 二叉树的最小深度</span></h4><p>这题我倒是不会。</p><ol><li><p>思路 1：<br>层序遍历，（我怎么没想到），对于每层元素，一旦存在叶子节点，则找到最小深度，立即返回当前深度即可：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                TreeNode* pNode = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(pNode-&gt;left) que.<span class="built_in">push</span>(pNode-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(pNode-&gt;right) que.<span class="built_in">push</span>(pNode-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(!pNode-&gt;left &amp;&amp; !pNode-&gt;right) &#123;</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li><li><p><mark>思路 2：</mark><br>递归。这里相较于求最大深度的那道题来说，略有不同。<br>当前节点的最小深度，并非单纯的是 <code>1 + min(lhs, rhs)</code> 这么简单，因为这样我们会把一些不符题意的节点算进来。<br>注意看题，我们要找到的是叶子节点，也就是左右两个子节点都为空。<br>但 <code>1 + min(lhs, rhs)</code> 会把 “左节点为空，右节点非空” or “左节点非空，右节点为空” 给算进来。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lhs = <span class="built_in">minDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rhs = <span class="built_in">minDepth</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rhs;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + lhs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(lhs, rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li></ol><h4 id="10-222-完全二叉树的节点个数"><a class="anchor" href="#10-222-完全二叉树的节点个数">#</a> 10、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC1jb21wbGV0ZS10cmVlLW5vZGVzLw==">222. 完全二叉树的节点个数</span></h4><ol><li><p>思路 1：<br>一上来想到的当然就是我最爱的层序遍历了：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> layer_size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; layer_size; ++i) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>但是题目既然给了 “完全二叉树” 这个条件，肯定有用，但是这里如果我们用层序遍历的话，没利用上这个条件。<p></p></li><li><p>思路 2：<br>递归。</p></li></ol><p>这里的思路是，分别求左右子树的深度，如果左右子树的深度相等，这说明该树为满二叉树，那么根据公式可求得节点数量；如果左右子树深度不相等，则递归分别求左右子树的数量，当前子树的总节点数等于 1 + 左节点子树节点数 + 右节点子树节点数：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* pLeft = root-&gt;left, *pRight = root-&gt;right;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="number">0</span>, rightDepth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pLeft) &#123;</span><br><span class="line">            pLeft = pLeft-&gt;left;</span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pRight) &#123;</span><br><span class="line">            pRight = pRight-&gt;right;</span><br><span class="line">            rightDepth++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h4 id="11-110-平衡二叉树"><a class="anchor" href="#11-110-平衡二叉树">#</a> 11、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iYWxhbmNlZC1iaW5hcnktdHJlZS8=">110. 平衡二叉树</span></h4><p><strong>平衡二叉树</strong> 是指该树所有节点的左右子树的深度相差不超过 1。</p><ol><li><mark>思路 1：</mark><br>这题我没想出来 😦</li></ol><p>思路就是，递归求左右子节点的高度，判断其差值是否大于 / 小于 1。<br>同时，在求子节点的高度是，如果子树已经是一个非平衡二叉树了，直接返回 -1，用于标记。否则返回子树的高度；<br>对于当前节点，判断左右子树的高度差是否大于一，大于则非平衡，同样地，返回 -1 用于标记。否则，返回 1 + 左右子树的高度的最大值。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lhs_height = <span class="built_in">getHeight</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(lhs_height == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> rhs_height = <span class="built_in">getHeight</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(rhs_height == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(lhs_height - rhs_height) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(lhs_height, rhs_height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">getHeight</span>(root) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h4 id="12-257-二叉树的所有路径"><a class="anchor" href="#12-257-二叉树的所有路径">#</a> 12、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wYXRocy8=">257. 二叉树的所有路径</span></h4><p>#回溯</p><ol><li><mark>思路 1：</mark><br>这里采用了递归和回溯的思想，从当前节点开始向下递归遍历，如果遇到叶子节点，则视为找到答案，保存答案，同时，返回上一节点，即回溯，找寻下一个可能的节点。</li></ol><p>具体地，维护一个 result 用于存储最终的答案，用于一个 path 用于存储当前走过的路径。每遍历一个节点，把当前节点压入 path，直到叶子节点，则视为找到答案，遍历 path 构造答案压入 result 中。每执行完一次递归，（即调用 <code>traversal</code> ）回来之后要 pop，以模拟回溯。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right) &#123;</span><br><span class="line">            string sPath;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">                sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            &#125; sPath[sPath.<span class="built_in">size</span>()<span class="number">-2</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 去除多余的 &quot;-&gt;&quot;</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(sPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里左子节点和右子节点的遍历顺序无所谓，可颠倒，所以我刻意写的先右后左的顺序。<p></p><p>对于上述代码，在思路不变的情况下，可以优化成以下形式：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, string path, vector&lt;string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        path += <span class="built_in">to_string</span>(cur-&gt;val);  <span class="comment">// 当前节点</span></span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right) <span class="built_in">traversal</span>(cur-&gt;right, path + <span class="string">&quot;-&gt;&quot;</span>, result); <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left) <span class="built_in">traversal</span>(cur-&gt;left, path + <span class="string">&quot;-&gt;&quot;</span>, result); <span class="comment">// 左</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        string path;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>之前，我们每找到一个结果，要重新遍历整个 path 数组来构造答案，我们其实可以直接传递字符串，在传递过程中不断增加 / 删除节点。这样，我们把递归函数传参中的 path 改为值传递，每次调用时加上 “-&gt;”，在递归函数中在加上值 &quot;cur-val&quot;，而由于是值传递，递归返回时则自动回溯，不需要 pop 操作。<p></p><ol start="2"><li><mark>思路 2：</mark><br>迭代法。</li></ol><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; treeSt;  <span class="comment">// 保存树的遍历节点</span></span><br><span class="line">        stack&lt;string&gt; pathSt;  <span class="comment">// 保存遍历路径的节点</span></span><br><span class="line">        vector&lt;string&gt; result;  <span class="comment">// 保存最终路径集合</span></span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> result;</span><br><span class="line">        treeSt.<span class="built_in">push</span>(root);</span><br><span class="line">        pathSt.<span class="built_in">push</span>(<span class="built_in">to_string</span>(root-&gt;val));</span><br><span class="line">        <span class="keyword">while</span>(!treeSt.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 当前节点</span></span><br><span class="line">            TreeNode* node = treeSt.<span class="built_in">top</span>(); treeSt.<span class="built_in">pop</span>();</span><br><span class="line">            string path = pathSt.<span class="built_in">top</span>(); pathSt.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">                treeSt.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                pathSt.<span class="built_in">push</span>(path + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(node-&gt;left-&gt;val));  <span class="comment">// 注意在这里隐含了回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">                treeSt.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                pathSt.<span class="built_in">push</span>(path + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(node-&gt;right-&gt;val));  <span class="comment">// 注意在这里隐含了回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h4 id="13-404-左叶子之和"><a class="anchor" href="#13-404-左叶子之和">#</a> 13、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdW0tb2YtbGVmdC1sZWF2ZXMv">404. 左叶子之和</span></h4><ol><li><p>思路 1：<br>递归，逐步拆解问题成更小规模的子问题。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">leftleaves</span><span class="params">(TreeNode* root, <span class="type">bool</span> isLeft)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; isLeft) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftleaves</span>(root-&gt;left, <span class="literal">true</span>) + <span class="built_in">leftleaves</span>(root-&gt;right, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root ? <span class="built_in">leftleaves</span>(root-&gt;left, <span class="literal">true</span>) + <span class="built_in">leftleaves</span>(root-&gt;right, <span class="literal">false</span>) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里我们需要有一个额外的标志来判断当前节点是否为左边的节点，需要靠父节点来判断，即从父节点调用前就明确。<p></p></li><li><p>思路 2：<br>有递归，自然就有迭代法，同理，我们这里入栈时多压入一个标志位，每次 pop 的时候同时 pop 标志位，用以判断：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* LEFT = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">-1</span>);</span><br><span class="line">        TreeNode* RIGHT = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">-1</span>);</span><br><span class="line">        st.<span class="built_in">push</span>(root); st.<span class="built_in">push</span>(RIGHT);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* pSide = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* pNode = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pSide == LEFT &amp;&amp; !pNode-&gt;left &amp;&amp; !pNode-&gt;right) &#123;</span><br><span class="line">                result += pNode-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;left) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(pNode-&gt;left); st.<span class="built_in">push</span>(LEFT);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;right) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(pNode-&gt;right); st.<span class="built_in">push</span>(RIGHT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">delete</span> LEFT, <span class="keyword">delete</span> RIGHT;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li></ol><h4 id="14-513-找树左下角的值"><a class="anchor" href="#14-513-找树左下角的值">#</a> 14、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWJvdHRvbS1sZWZ0LXRyZWUtdmFsdWUv">513. 找树左下角的值</span></h4><ol><li><p>思路 1：<br>最先想到的就是我最爱的层序遍历，每一层一开始先记录最左边的元素，逐层更新：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> layer_size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; layer_size; ++i) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) ret = node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li><li><p>思路 2：<br>递归，维护一个深度值，当遇到叶子节点时如果深度大于当前记录的最大深度值，则更新。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="type">int</span> maxDepth = INT_MIN;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(depth &gt; maxDepth) &#123;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">                result = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;left, depth + <span class="number">1</span>);  <span class="comment">// 隐含回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;right, depth + <span class="number">1</span>);  <span class="comment">// 隐含回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里先遍历左子树，再遍历右子树。在这段代码中，左子树会在右子树之前被处理，因此在最底层的情况下，左子节点会先被记录。由于左子节点会优先被遍历并记录，只有在左子节点没有更新时，才会记录右子节点的值。这保证了在同一深度下，最先遇到的叶子节点是左节点，从而实现了寻找最底层的最左侧节点的目标。<p></p></li></ol><h4 id="15-112-路径总和"><a class="anchor" href="#15-112-路径总和">#</a> 15、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS8=">112. 路径总和</span></h4><p>#回溯</p><ol><li><p>思路 1：<br>二叉树的题目，除了那些一上来明显能想到思路的，否则基本上就是先思考递归写法，然后再考虑把递归写法优化成迭代写法。这里我们用递归写法，判断当前是否存在路径，等价于求两个子树是否存在路径，只需要其中一个存在即可，所以是 “或” 的关系。每次递归时，把 targetSum 减去当前节点的值，则我们只需要在叶子节点判断 targetSum 是否等于叶子节点的 val 即可。这里的回溯隐含在函数传参 targetSum 中。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPathSumExist</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val == targetSum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isPathSumExist</span>(root-&gt;left, targetSum - root-&gt;val) || <span class="built_in">isPathSumExist</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isPathSumExist</span>(root, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li><li><p><mark>思路 2：</mark></p></li></ol><p>第二种思路是迭代，这种思路的关键是怎么处理 targetSum 以及怎么回溯。<br>这里的做法是，在栈中压入的是一个 pair，同时记录当前节点和到当前位置的路径和。<br>则在叶子节点时只需要判断当前位置的路径和是否等于 targetSum 即可，压入普通子节点时则是通过将当前节点的 val 与 sum 求和压入，这里就实现了隐含的回溯。（因为我们的 sum 是维护在过程中的，是暂存在每一个节点的，每一次访问栈中元素 pop 时就回溯了。）<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        stack&lt;std::pair&lt;TreeNode*, <span class="type">int</span>&gt;&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;TreeNode*, <span class="type">int</span>&gt;(root, root-&gt;val));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [node, sum] = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; sum == targetSum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;TreeNode*, <span class="type">int</span>&gt;(node-&gt;left, sum + node-&gt;left-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;TreeNode*, <span class="type">int</span>&gt;(node-&gt;right, sum + node-&gt;right-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h4 id="16-106-从中序与后序遍历序列构造二叉树"><a class="anchor" href="#16-106-从中序与后序遍历序列构造二叉树">#</a> 16、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1pbm9yZGVyLWFuZC1wb3N0b3JkZXItdHJhdmVyc2FsLw==">106. 从中序与后序遍历序列构造二叉树</span></h4><ol><li><mark>思路 1：</mark></li></ol><p>首先有个基础的知识点，即如何利用中序遍历和后序遍历来确定一个二叉树：<br>我们知道后序遍历的顺序是 “左右中”，所以 postorder 数组中的最后一个元素一定是中间节点。<br>其次，我们知道中序遍历的顺序是 “左中右”，所以我们可以利用上面得到的中间节点，在 inorder 数组中找到中间节点的位置，然后把中序遍历数组的左边和右边分出来。<br>最后，我们再根据 “中序遍历和后序遍历的长度应该一致”，可以利用中序遍历分割的子数组长度，来确认如何分割后续遍历的数组。</p><p>于是这题的思路就是，递归，每一次利用后序遍历的最后一个元素来定位中间节点在中序遍历中的位置，然后将数组一分为二（实际上是一分为三：当前节点 —— 即中间节点、左子树、右子树），再利用得到的数组长度反过来去分割后序遍历，同样得到左子树和右子树（至于结尾的中间节点，我们直接 pop 掉，因为我们在处理中序遍历的时候已经生成了中间节点了，不需要重复累赘操作）</p><p>而这里如何递归也是一个关键点。首先，我们每次迭代都能得到一个中间节点，该节点的值就是后序遍历的尾端元素。而其左右子树，我们则通过递归左右子树的子数组来得到。所以，递归终止的条件，就是后序遍历的数组长度为 0。</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSplitVectorIdx</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; input, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(input[i] == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid_val = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(mid_val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(postorder.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid_idx = <span class="built_in">getSplitVectorIdx</span>(inorder, mid_val);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_inorder</span><span class="params">(inorder.begin(), inorder.begin() + mid_idx)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_inorder</span><span class="params">(inorder.begin() + mid_idx + <span class="number">1</span>, inorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        postorder.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_postorder</span><span class="params">(postorder.begin(), postorder.begin() + left_inorder.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_postorder</span><span class="params">(postorder.begin() + left_inorder.size(), postorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        node-&gt;left = <span class="built_in">traversal</span>(left_inorder, left_postorder);</span><br><span class="line">        node-&gt;right = <span class="built_in">traversal</span>(right_inorder, right_postorder);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>这里有一个优化点，就是每一次迭代都要去 “分割数组”，而我们这里的 “分割” 是通过生成数组来实现的，会有消耗。<br>我们完全可以只记录 inorder 和 postorder 两个数组的头尾 index 即可。然后在具体的迭代中，我们再根据两个 index 求得 4 个 index。这里就不展开了。</p><p>另外，还要注意，题目里给定了一个条件，就是两个遍历的数组里面不包含相同元素，这一点很重要。不然我们没法定位。</p><p>最后，<br>前序和中序可以唯一确定一棵二叉树。<br>后序和中序可以唯一确定一棵二叉树。<br>前序和后续不可以唯一确定一棵二叉树。</p><h4 id="17-654-最大二叉树"><a class="anchor" href="#17-654-最大二叉树">#</a> 17、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWJpbmFyeS10cmVlLw==">654. 最大二叉树</span></h4><ol><li>思路 1：</li></ol><p>有了上一题的 “经验教训”，我们这一题基本就知道怎么通过递归来实现了。<br>这题有更强的递归模拟性，也跟上一题一样是划分数组，所以这一次我们直接通过传递数组范围的方式，避免了数组的创建和拷贝。对于范围，我们始终以左闭右开区间为准。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxVal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt; end; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; max) &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                ret = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;  <span class="comment">// [start, end)</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">findMaxVal</span>(nums, start, end);</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[idx]);</span><br><span class="line"></span><br><span class="line">        node-&gt;left = <span class="built_in">traversal</span>(nums, start, idx);</span><br><span class="line">        node-&gt;right = <span class="built_in">traversal</span>(nums, idx + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里要注意一个小细节就是，如果我们要以数组的范围作为参数传递，则递归终止的条件不能以数组是否为空来判断，而是应该判断 start 是否大于等于 end。<p></p><h4 id="18-617-合并二叉树"><a class="anchor" href="#18-617-合并二叉树">#</a> 18、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS10d28tYmluYXJ5LXRyZWVzLw==">617. 合并二叉树</span></h4><ol><li>思路 1：<br>递归模拟，现在基本有经验了，递归函数中处理的是【<strong>当前节点</strong>】，同时，当前节点的左右两个子节点通过调用递归函数交给下一轮递归来得到。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">merge</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root1 &amp;&amp; root2) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(root1 &amp;&amp; !root2) <span class="keyword">return</span> root1;</span><br><span class="line"></span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root1-&gt;val + root2-&gt;val);</span><br><span class="line">        node-&gt;left = <span class="built_in">merge</span>(root1-&gt;left, root2-&gt;left);</span><br><span class="line">        node-&gt;right = <span class="built_in">merge</span>(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>当然，这上面的这个解法由于是我 “简单应付” 的，所以效率不高，还申请了新的内存，有优化空间。优化后可得：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> root2; &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> root1; &#125;</span><br><span class="line"></span><br><span class="line">        root1-&gt;val += root2-&gt;val;</span><br><span class="line">        root1-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);</span><br><span class="line">        root1-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><ol start="2"><li>思路 2：<br>有递归的地方基本就有迭代。</li></ol><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> root2; &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> root1; &#125;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root1);</span><br><span class="line">        que.<span class="built_in">push</span>(root2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* pNode1 = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* pNode2 = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            pNode1-&gt;val += pNode2-&gt;val;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pNode1-&gt;left &amp;&amp; pNode2-&gt;left) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(pNode1-&gt;left);</span><br><span class="line">                que.<span class="built_in">push</span>(pNode2-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pNode1-&gt;right &amp;&amp; pNode2-&gt;right) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(pNode1-&gt;right);</span><br><span class="line">                que.<span class="built_in">push</span>(pNode2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!pNode1-&gt;left &amp;&amp; pNode2-&gt;left) &#123;</span><br><span class="line">                pNode1-&gt;left = pNode2-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!pNode1-&gt;right &amp;&amp; pNode2-&gt;right) &#123;</span><br><span class="line">                pNode1-&gt;right = pNode2-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里需要注意的是，虽然我们每一轮循环处理的是当前节点，但是我们只需要把两个值（如果存在）相加即可，并不需要通过 “父节点” 来做这件事。同时，这里如果 <code>pNode1-&gt;xxx &amp;&amp; !pNode2-&gt;xxx</code> 的情况没有写出相应的逻辑，因为不用处理。<p></p><h4 id="19-700-二叉搜索树中的搜索"><a class="anchor" href="#19-700-二叉搜索树中的搜索">#</a> 19、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW4tYS1iaW5hcnktc2VhcmNoLXRyZWUv">700. 二叉搜索树中的搜索</span></h4><p>二叉搜索树的特性是，左子树节点的值均小于根节点的值，右子树节点的值均大于根节点的值。<br>二叉搜索树的中序遍历得到的是一个有序的数列。</p><ol><li>思路 1：<br>直接迭代，类似于处理链表：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        TreeNode* ret = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val == val) &#123;</span><br><span class="line">                ret = root;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; val) &#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left) &#123;</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; val) &#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right) &#123;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>我上面写得太累赘了，可以优化：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val &gt; val) &#123;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; val) &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><ol start="2"><li>思路 2：<br>递归，但我怀疑正常人第一反应真的会想到这个吗...<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || root-&gt;val == val) &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; val) &#123; <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left, val); &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; val) &#123; <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val); &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h4 id="20-98-验证二叉搜索树"><a class="anchor" href="#20-98-验证二叉搜索树">#</a> 20、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZGF0ZS1iaW5hcnktc2VhcmNoLXRyZWUv">98. 验证二叉搜索树</span></h4><p>这里我写了两种错误的做法。<strong>注意，以下两个写法无法通过全部测试用例！！</strong></p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">// 	bool isValidBST(TreeNode* root) &#123;</span></span><br><span class="line"><span class="comment">// 		if(!root) return true;</span></span><br><span class="line"><span class="comment">// 		if(root-&gt;left &amp;&amp; root-&gt;left-&gt;val &gt;= root-&gt;val) &#123;</span></span><br><span class="line"><span class="comment">// 			return false;</span></span><br><span class="line"><span class="comment">// 		&#125;</span></span><br><span class="line"><span class="comment">// 		if(root-&gt;right &amp;&amp; root-&gt;right-&gt;val &lt;= root-&gt;val) &#123;</span></span><br><span class="line"><span class="comment">// 			return false;</span></span><br><span class="line"><span class="comment">// 		&#125;</span></span><br><span class="line"><span class="comment">// 		return isValidBST(root-&gt;left) &amp;&amp; isValidBST(root-&gt;right);</span></span><br><span class="line"><span class="comment">// 	&#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure><br>在我的第一版写法中，我企图通过一个简单的递归来解题。但是遇到了这样的测试用例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  5</span><br><span class="line"> / \</span><br><span class="line">4    6</span><br><span class="line">    / \</span><br><span class="line">   3   7</span><br></pre></td></tr></table></figure><p></p><p>于是我写了第二版，要解决子节点和祖节点的大小问题：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">// private:</span></span><br><span class="line"><span class="comment">// 	bool traversal(TreeNode* root, TreeNode* last, int dir) &#123;</span></span><br><span class="line"><span class="comment">// 		if(!root) return true;</span></span><br><span class="line"><span class="comment">// 		if(root-&gt;left &amp;&amp; root-&gt;left-&gt;val &gt;= root-&gt;val) &#123;</span></span><br><span class="line"><span class="comment">// 			return false;</span></span><br><span class="line"><span class="comment">// 		&#125;</span></span><br><span class="line"><span class="comment">// 		if(root-&gt;right &amp;&amp; root-&gt;right-&gt;val &lt;= root-&gt;val) &#123;</span></span><br><span class="line"><span class="comment">// 			return false;</span></span><br><span class="line"><span class="comment">// 		&#125;</span></span><br><span class="line"><span class="comment">// 		if(last &amp;&amp; dir == 0 &amp;&amp; root-&gt;right &amp;&amp; root-&gt;right-&gt;val &gt;= last-&gt;val) &#123;</span></span><br><span class="line"><span class="comment">// 			return false;</span></span><br><span class="line"><span class="comment">// 		&#125;</span></span><br><span class="line"><span class="comment">// 		if(last &amp;&amp; dir == 1 &amp;&amp; root-&gt;left &amp;&amp; root-&gt;left-&gt;val &lt;= last-&gt;val) &#123;</span></span><br><span class="line"><span class="comment">// 			return false;</span></span><br><span class="line"><span class="comment">// 		&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 		return traversal(root-&gt;left, root, 0) &amp;&amp; traversal(root-&gt;right, root, 1);</span></span><br><span class="line"><span class="comment">// 	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">// 	bool isValidBST(TreeNode* root) &#123;</span></span><br><span class="line"><span class="comment">// 		return traversal(root, nullptr, 0);</span></span><br><span class="line"><span class="comment">// 	&#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure><p></p><p>通过了 95% 的测试用例，但是在这个测试用例卡住了：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">            120</span><br><span class="line">         /        \</span><br><span class="line">       70            140</span><br><span class="line">     /   \           /   \</span><br><span class="line">   50    100        130    160</span><br><span class="line">  / \    / \        / \     / \</span><br><span class="line">20  55  75  110   119 135  150 200</span><br></pre></td></tr></table></figure><p></p><p>那么，正解是什么呢？<br>注意，我们要判断它是不是二叉搜索树，那么，我们只要判断它是否具有二叉搜索树的特性即可！<br>而二叉搜索树有什么特性呢？—— 中序遍历的结果是单调递增的！<br>那么这道题就变成一道简单的 “中序遍历”+“判断数组是否单调递增” 了。</p><ol><li><p>思路 1：<br>思路如上所述。<br>这里采用中序遍历的迭代写法：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;  <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 中</span></span><br><span class="line">                cur = cur-&gt;right;  <span class="comment">//右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; result.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i<span class="number">-1</span>] &gt;= result[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里中序的迭代写法需要理解，一路无脑向左遍历直到不再有左子节点，（则当前节点就是左节点），压入当前节点。如果当前节点没有右子节点，则回到上一个节点（即中节点），压入中节点，再遍历右节点。左、中、右，中序遍历。<p></p></li><li><p>思路 2：<br>有迭代的地方就有递归。这里同样的思路，用递归法实现中序遍历，同样能够解题：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxVal = LONG_MIN;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> left = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(maxVal &lt; root-&gt;val) &#123;</span><br><span class="line">            maxVal = root-&gt;val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> right = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里维护一个 “最大值”，该值可代表遍历左子树时遇到的最大值。则有，如果该值大于当前 <code>root-&gt;val</code> 值，说明不合题意，返回 false，其余情况下更新该值。由于 <code>maxVal</code> 表示左子树的最大值，且当处理当前节点时，我们会将其与当前节点的值进行对比并更新，所以当我们开始遍历右子树时，该值 <code>maxVal</code> 已然是根节点的值，所以此时如果我们的右子树的左端出现比该值小的情况，会被判为 false。也就剔除了上面的 120 &gt; 119 的测试用例的情况。<p></p></li></ol><p>而这种解法的弊端，就是如果测试用例中如果存在 <code>LONG_MIN</code> ，那么我们无法写一个更小的值来实现上述逻辑。</p><p>于是有了下面优化版的解法：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* pPre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//确定终止条件：空节点也是一种二叉搜索树</span></span><br><span class="line">        <span class="keyword">if</span>(!root) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左孩子节点是二叉搜索树</span></span><br><span class="line">        <span class="type">bool</span> left = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左、中、右符合从小到大的顺序</span></span><br><span class="line">        <span class="keyword">if</span>(pPre != <span class="literal">nullptr</span> &amp;&amp; pPre-&gt;val &gt;= root-&gt;val) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        pPre = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右孩子节点是二叉搜索树</span></span><br><span class="line">        <span class="type">bool</span> right = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里的 pPre 的逻辑很绕很绕，要理解这个思路，我们应该采用理解上面的 <code>maxVal</code> 时的脑回路来理解这个解法，不要逐层递归往下无限代入去思考，我们只需要高屋建瓴地思考即可：<p></p><p>首先理解 pPre 的本质，就是用来表示 “上一个节点”，其在遍历完左子树后更新，更新后其指向【<strong>当前节点</strong>】然后再开始递归遍历右子树。所以在遍历右子树时，由于是中序遍历，先遍历左边节点，所以不会更新 pPre。即，当我们遍历右子树的左边时，pPre 仍然指向根节点。故可以避免 120 &gt; 119 的情况。</p><h4 id="21-530-二叉搜索树的最小绝对差"><a class="anchor" href="#21-530-二叉搜索树的最小绝对差">#</a> 21、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWFic29sdXRlLWRpZmZlcmVuY2UtaW4tYnN0Lw==">530. 二叉搜索树的最小绝对差</span></h4><ol><li><p>思路 1：<br>由于是二叉搜索树，所以自然而然想到其特性 —— 中序遍历的结果是有序的。<br>所以我们的思路就是先对其中序遍历，然后对结果进行一次遍历求相邻元素的差值。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(node || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; result.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> diff = result[i] - result[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(diff &lt; ret) ret = diff;</span><br><span class="line">        &#125; <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>中序遍历的迭代写法还是很不熟，可能是理解不到位，需要多写。<p></p></li><li><p>思路 2：<br>同样的思路，但是用递归来写，就简单多了：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) &#123;</span><br><span class="line">            <span class="built_in">inorderTraversal</span>(root-&gt;left, vec);</span><br><span class="line">        &#125;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">inorderTraversal</span>(root-&gt;right, vec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root, result);</span><br><span class="line">        <span class="type">int</span> ret = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; result.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> diff = result[i] - result[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(diff &lt; ret) ret = diff;</span><br><span class="line">        &#125; <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p></li></ol><h4 id="22-501-二叉搜索树中的众数"><a class="anchor" href="#22-501-二叉搜索树中的众数">#</a> 22、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLW1vZGUtaW4tYmluYXJ5LXNlYXJjaC10cmVlLw==">501. 二叉搜索树中的众数</span></h4><ol><li>思路 1：<br>由于题目进阶要求说不要使用额外空间，所以这里我只用了个 vector，没用其他诸如 set、map 之类的复杂结构。<br>思路是，中序遍历，得到有序的数据，每次遍历时，计算当前数值出现的次数，次数大于最大记录，则更新最大记录，同时清空 vector，即更新，把当前数值作为可能的结果压入 vector。如果次数等于最大记录，由于可能存在多个众数，所以该值可能是可能的结果，故压入 vector，但不需要提前清空 vector，因为之前的数据也仍然有效。只有更新最大记录时需要更新清空 vector。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur_mode = root-&gt;val;</span><br><span class="line">        <span class="type">int</span> cur_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; mode;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">while</span>(node || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;val == cur_mode) &#123;</span><br><span class="line">                    ++cur_len;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur_mode = node-&gt;val;</span><br><span class="line">                    cur_len = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur_len &gt; max_len) &#123;</span><br><span class="line">                    max_len = cur_len;</span><br><span class="line">                    mode.<span class="built_in">clear</span>();</span><br><span class="line">                    mode.<span class="built_in">push_back</span>(cur_mode);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_len == max_len) &#123;</span><br><span class="line">                    mode.<span class="built_in">push_back</span>(cur_mode);</span><br><span class="line">                &#125;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> mode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>这里有另一种写法，大差不差，维护一个 pre 指针，用于表示 “上一个节点”，然后在中序遍历过程中拿 pre 和 node 作比较即可，就不需要像上面那样维护 cur_mode 了。</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; mode;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(node || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(!pre) &#123;  <span class="comment">// 第一个节点</span></span><br><span class="line">                    cur_len = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == node-&gt;val) &#123;</span><br><span class="line">                    ++cur_len;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur_len = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur_len &gt; max_len) &#123;</span><br><span class="line">                    max_len = cur_len;</span><br><span class="line">                    mode.<span class="built_in">clear</span>();</span><br><span class="line">                    mode.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur_len == max_len) &#123;</span><br><span class="line">                    mode.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                pre = node;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> mode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>但其实大同小异，思路都是相同的。<p></p><p>这里如果贪图方便的话，即不考虑进阶限制的内存要求，则可以用 set 之类的无脑进行统计，最后再处理分析即可。</p><ol start="2"><li><mark>思路 2：</mark><br>手贱点开官方题解看了一眼，发现有一个叫做 “Morris 中序遍历” 的高级东西。<br>暂不展开 😃</li></ol><h4 id="23-236-二叉树的最近公共祖先"><a class="anchor" href="#23-236-二叉树的最近公共祖先">#</a> 23、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUv">236. 二叉树的最近公共祖先</span></h4><ol><li><mark>思路 1：</mark></li></ol><p>没想出来...</p><p>思路是递归。<br>具体地，我们递归地向左右子树去遍历，如果找到 p、q 或遇到空指针则返回。<br>则有，当我们当前节点左右两个子树返回的结果都非空，则说明当前节点就是要找的目标节点。<br>如果其中一个节点为空，说明目标并不存在于该子树，则返回另一边的节点。<br>另外，注意，节点是逐层回溯向上传递上来的。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q || root == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">        <span class="keyword">if</span>(!left) &#123; <span class="keyword">return</span> right; &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><ol start="2"><li><mark>思路 2：</mark><br>来自官方的题解。<br>这个思路比较简单粗暴，我们维护一张哈希表，用于存储每个节点的父节点。先遍历一遍整棵二叉树，填哈希表。<br>然后我们从 p 节点开始，沿着我们通过哈希表得到的 “血脉关系” 不断向上遍历父节点，把所有访问过的元素标记为已访问。<br>（通过另一张哈希表实现标记）<br>然后我们从 q 节点开始，同样沿着血脉向上遍历，同时判断当前节点是否曾经在遍历 p 时被标记过，是则找到目标。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, TreeNode*&gt; parents;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; seen;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) &#123;</span><br><span class="line">            parents[root-&gt;left-&gt;val] = root;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) &#123;</span><br><span class="line">            parents[root-&gt;right-&gt;val] = root;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        parents[root-&gt;val] = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">            seen[p-&gt;val] = <span class="literal">true</span>;</span><br><span class="line">            p = parents[p-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q) &#123;</span><br><span class="line">            <span class="keyword">if</span>(seen[q-&gt;val]) <span class="keyword">return</span> q;</span><br><span class="line">            q = parents[q-&gt;val];</span><br><span class="line">        &#125; <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h4 id="24-235-二叉搜索树的最近公共祖先"><a class="anchor" href="#24-235-二叉搜索树的最近公共祖先">#</a> 24、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXNlYXJjaC10cmVlLw==">235. 二叉搜索树的最近公共祖先</span></h4><ol><li><p>思路 1：<br>这题抛开 “二叉搜索树” 的条件先不管，那么完全等同于上一题。所以上一题的两个思路都可以应用过来：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">findAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q || root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left = <span class="built_in">findAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">findAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; !right) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findAncestor</span>(root, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里我是隔天做这道题，凭回忆把题解写出来了，一看就会，一写就对，不错不错～<p></p></li><li><p>思路 2：<br>另一个思路同样地也是上一道题的题解，力扣官方题解之一：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, unordered_map&lt;<span class="type">int</span>, TreeNode*&gt;&amp; parents)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) parents[root-&gt;left-&gt;val] = root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) parents[root-&gt;right-&gt;val] = root;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left, parents);</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right, parents);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, TreeNode*&gt; parents;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; seen;</span><br><span class="line">        parents[root-&gt;val] = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root, parents);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">            seen[p-&gt;val] = <span class="literal">true</span>;</span><br><span class="line">            p = parents[p-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q) &#123;</span><br><span class="line">            <span class="keyword">if</span>(seen[q-&gt;val]) <span class="keyword">return</span> q;</span><br><span class="line">            q = parents[q-&gt;val];</span><br><span class="line">        &#125; <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>我凭记忆把它写出来，一次就通过啦，真棒～<p></p></li></ol><p>但是上面这两个题解都没用到 “二叉搜索树” 这个条件，是对条件的浪费。应该要有更优的解法才对。</p><ol start="3"><li><mark>思路 3：</mark><br>众所周知，二叉搜索树的特点就是有序。<br>然后我们 “稍加思考”，就能发现，对于公共组先 x，满足 <code>p-&gt;val &lt; x-&gt;val &lt; q-&gt;val</code> ，且当该条件满足时，一定就是最近公共组先。于是我们可以利用这个特性，一次遍历就能找到目标（且并不需要遍历整棵树）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里用的是递归法，同样地，我们可以用递归法来写：</li></ol><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h4 id="25-701-二叉搜索树中的插入操作"><a class="anchor" href="#25-701-二叉搜索树中的插入操作">#</a> 25、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnNlcnQtaW50by1hLWJpbmFyeS1zZWFyY2gtdHJlZS8=">701. 二叉搜索树中的插入操作</span></h4><ol><li>思路 1：<br>本来以为我的这个解法只能通过部分用例，没想到除了一个边界情况，其他全过了。<br>思路就是，从根节点开始遍历二叉搜索树，判断当前节点的值与待插入的目标值 val 的关系，利用二叉搜索树的有序的特性，如果当前值偏大，则往左子树遍历，否则往右子树遍历。直到遍历的结果为空节点，则标明找到目标位置，在此插入节点即可。为了实现插入，实际上我们要从前一个节点开始判断下一个节点是否为空。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt; val) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right) &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>（卧槽！写完去看题解，我居然写出了和官方题解几乎一模一样的写法。）</li></ol><p>然后，上述代码可以通过递归的写法进行简化：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(val &lt; root-&gt;val) &#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>一下子简洁明了，这里， <code>insertIntoBST</code> 将返回值赋值给 left 或者 right，就相当于我们通过前节点来修改插入后节点。<p></p><p>另外，虽然这道题标的难度是中等，但感觉实际上是简单题。</p><h4 id="26-450-删除二叉搜索树中的节点"><a class="anchor" href="#26-450-删除二叉搜索树中的节点">#</a> 26、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtbm9kZS1pbi1hLWJzdC8=">450. 删除二叉搜索树中的节点</span></h4><ol><li><mark>思路 1：</mark></li></ol><blockquote><p>有以下五种情况：</p></blockquote><ul><li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li><li>找到删除的节点<ul><li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回 nullptr 为根节点</li><li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li><li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li><li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li></ul></li></ul><p>这里第五种情况的处理方式我没想到，但是一旦知道了又很容易理解，实质上还是利用二叉搜索树的有序特性。</p><p>这里首先遍历查找 key 是否存在，大了往左，小了往右。<br>然后再根据情况进行节点替换，这里我们需要有一个变量 pre 记录先前节点，同时还要有一个 dir 记录方向，以方便改变先前节点的指向，用于重新指向新的值。</p><p>这里的边界条件，就是可能 root 就是我们要删除的对象，而 root 的 pre 为 nullptr，所以需要特殊处理。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">repoint</span><span class="params">(TreeNode** root, TreeNode* pre, <span class="type">int</span> dir, TreeNode* tobepoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pre) &#123;  <span class="comment">// case we remove root</span></span><br><span class="line">            *root = tobepoint;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(dir) &#123;</span><br><span class="line">                pre-&gt;right = tobepoint;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre-&gt;left = tobepoint;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// find node</span></span><br><span class="line">        <span class="type">int</span> dir = <span class="number">-1</span>;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt; key) &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                dir = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;val &lt; key) &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                dir = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// combine two tree</span></span><br><span class="line">        <span class="keyword">if</span>(!cur) <span class="keyword">return</span> root;  <span class="comment">// key doesn&#x27;t exist</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left &amp;&amp; !cur-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">repoint</span>(&amp;root, pre, dir, cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;left &amp;&amp; cur-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">repoint</span>(&amp;root, pre, dir, cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">repoint</span>(&amp;root, pre, dir, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left &amp;&amp; cur-&gt;right) &#123;</span><br><span class="line">            TreeNode* most_left = cur-&gt;right;</span><br><span class="line">            <span class="built_in">repoint</span>(&amp;root, pre, dir, cur-&gt;right);</span><br><span class="line">            <span class="keyword">while</span>(most_left-&gt;left) &#123;</span><br><span class="line">                most_left = most_left-&gt;left;</span><br><span class="line">            &#125; most_left-&gt;left = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> cur;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>当然，这里被我写复杂了。</p><ol start="2"><li>思路 2：<br>递归法，可以大大简化上面的流程。</li></ol><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == key) &#123;</span><br><span class="line">            TreeNode* ret = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left) &#123;</span><br><span class="line">                ret = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;right) &#123;</span><br><span class="line">                ret = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode* most_left = root-&gt;right;</span><br><span class="line">                <span class="keyword">while</span>(most_left-&gt;left) &#123;</span><br><span class="line">                    most_left = most_left-&gt;left;</span><br><span class="line">                &#125; most_left-&gt;left = root-&gt;left;</span><br><span class="line">                ret = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; key) &#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; key) &#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>这里，我们先看后半部分的代码，如果当前节点值偏大，我们知道要往左子树搜索，反之同理。这里我们用左右节点分别去接收递归函数的返回值，即，递归函数返回的内容就是我们要重新指向的位置。（这个回溯过程就大大简化了我们之前第一种写法中 pre、dir 的相关逻辑）。</p><p>当遍历到符合条件时，我们根据当前节点左右子树的关系，来决定返回什么内容。这里不再赘述。</p><h4 id="27-669-修剪二叉搜索树"><a class="anchor" href="#27-669-修剪二叉搜索树">#</a> 27、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90cmltLWEtYmluYXJ5LXNlYXJjaC10cmVlLw==">669. 修剪二叉搜索树</span></h4><p>两年前不会的题，如今还是不会。真不应该 😦</p><ol><li><mark>思路 1：</mark></li></ol><p>递归处理这个问题，这里我们还是围绕 “二叉搜索树有序” 的特点来处理。</p><p>对于当前节点，我们判断节点的值 val 与 low 和 high 的关系：<br>如果 val &lt; low，说明当前节点 root 的左子树的数值就更是小于 low 了，属于要被裁剪的对象。<br>如果 val &gt; high，说明当前节点 root 的右子树的数值就更是大于 low 了，也属于要被裁剪的对象。<br>那么这里的裁剪逻辑是怎么实现的呢？其实这里 “返回另一边子树” 就相当于 “裁掉了不符合要求的子树” 了<br>而至于挑选返回的这一边子树，是不是完全符合要求，未必，但我们交给下一轮递归来进行选择。<br>而如果，当前节点的值处于 (low, high) 范围内，当然也同样不等同于就结束了，我们还要递归地处理左右子树。</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; low) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">            root-&gt;right = <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这个题解抄的力扣官方题解，官方好像也没对裁剪的节点进行 delete 释放内存，那就暂且不管了。<p></p><h4 id="28-108-将有序数组转换为二叉搜索树"><a class="anchor" href="#28-108-将有序数组转换为二叉搜索树">#</a> 28、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LXNvcnRlZC1hcnJheS10by1iaW5hcnktc2VhcmNoLXRyZWUv">108. 将有序数组转换为二叉搜索树</span></h4><p>这一题虽然到现在才遇到，但是在前面那些题的解题过程中，我一直想要实现这个功能，就能通过一次 “遍历原平衡二叉树” + 数据处理 + “重新生成平衡二叉树” 来解决一些问题了。</p><ol><li>思路 1：<br>这道题比较简单，这里我第一想到的方法就是递归，每一轮递归就找数组的中间位置的值作为新子树的根，然后该节点左右子节点就去接收递归调用的结果。</li></ol><p>为了避免反复构造新的数组，所以这里我直接传递索引 start 和 end 来表示新数组的范围。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        cur-&gt;left = <span class="built_in">traversal</span>(nums, start, mid);</span><br><span class="line">        cur-&gt;right = <span class="built_in">traversal</span>(nums, mid+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里我全程统一使用的是左闭右开区间。<p></p><h4 id="29-538-把二叉搜索树转换为累加树"><a class="anchor" href="#29-538-把二叉搜索树转换为累加树">#</a> 29、<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LWJzdC10by1ncmVhdGVyLXRyZWUv">538. 把二叉搜索树转换为累加树</span></h4><ol><li><mark>思路 1：</mark><br>实际上这道题并不难。<br>首先，二叉搜索树有序，左边的值小于中间的值，中间的值小于右边的值。<br>根据题意，是从右向左累加，所以自然而然地，这道题要以 “右中左” 的顺序进行遍历，这一点大家都能想到。<br>而累加，就是 “上一个值” + “当前值”，所以，我们只要通过一个 pre 变量记录 “上一个节点” 的值，然后每次遍历时加上该值即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cur) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line">        cur-&gt;val += pre;</span><br><span class="line">        pre = cur-&gt;val;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        pre = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>换成数组来思考更容易理解，二叉搜索树的中序遍历是一个递增数组，我们就是从数组尾端从头进行累加。<br>那么换成二叉树也是一样的，只不过我们是在操作数，所以这个遍历比较抽象 —— 但我们已经知道是 “右中左” 的遍历顺序了。</li></ol><p>在解这道题的时候，我犯了一个错误。 😦<br>我试图通过回溯的形式，从底往上进行累加。但这样不可行，虽然从右子树到中间节点的过程是自底向上的，但是从中间节点到左子树的过程又是自顶向下的。这样会遇到一个问题，就是左子树在递归时，从底往上累加回溯时返回的并非我们想要的结果，还需要带上根节点的值。</p><p>花了一两个小时写的下面的题解，但是连测试用例都过不了，主要是左子树在递归时，无法带上根节点的值进行累加。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">// private:</span></span><br><span class="line"><span class="comment">//     int traversal(TreeNode* node) &#123;</span></span><br><span class="line"><span class="comment">//         if(!node) return 0;</span></span><br><span class="line"><span class="comment">//         if(!node-&gt;left &amp;&amp; !node-&gt;right) return node-&gt;val;</span></span><br><span class="line"><span class="comment">//         int right_tree_sum = traversal(node-&gt;right);</span></span><br><span class="line"><span class="comment">//         node-&gt;val += right_tree_sum;</span></span><br><span class="line"><span class="comment">//         if(node-&gt;left) &#123;</span></span><br><span class="line"><span class="comment">//             node-&gt;left-&gt;val += node-&gt;val;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         int left_tree_sum = traversal(node-&gt;left);</span></span><br><span class="line"><span class="comment">//         if(node-&gt;left) &#123;</span></span><br><span class="line"><span class="comment">//             return node-&gt;left-&gt;val;</span></span><br><span class="line"><span class="comment">//         &#125; else &#123;</span></span><br><span class="line"><span class="comment">//             return node-&gt;val;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     TreeNode* convertBST(TreeNode* root) &#123;</span></span><br><span class="line"><span class="comment">//         if(!root) return nullptr;</span></span><br><span class="line"><span class="comment">//         traversal(root);</span></span><br><span class="line"><span class="comment">//         return root;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure><p></p><p>至此，二叉树的基本练习就告一段落。基本上，对于二叉树的题目，如果一上来没什么思路，就可以想尝试着用递归去拆分问题，或许就能够直接解决。递归相较于迭代，在处理一些问题时，不但更容易理解，而且可以通过递归的返回值来实现 “改变前一个节点的指向” 的问题。另外，我们也可以用一个 pre 变量来标示 “上一个” 状态，对此我们也做了几道相关的题，需要熟悉，不然的话用迭代法会很麻烦。</p><p>关于二叉搜索树的题，基本上都是利用了其有序的特点，一定要善用这个条件，题目不会无缘无故强调二叉搜索树。</p><p>二叉树的基础，即几种遍历方式，需要熟悉。无论是层序遍历，还是递归、迭代法的各种顺序的遍历。在中等难度的题目中，遍历顺序都已经变成一个微不足道的小细节，隐藏在题解中。有时候顺序对于解题很重要，有时候却又不重要。</p><p>另外，递归就意味着会有回溯，虽然我们在这一系列的题目里严格意义上来说只遇到过两次，但要了解。</p><div class="tags"><a href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag"><i class="ic i-tag"></i> 回溯</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-11-03 10:47:22" itemprop="dateModified" datetime="2024-11-03T10:47:22+08:00">2024-11-03</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝杯咖啡吧~</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Rick 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Rick 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Rick <i class="ic i-at"><em>@</em></i>R1ck's Playground</li><li class="link"><strong>本文链接：</strong> <a href="https://how2051.github.io/2024/11/03/007-%E4%BA%8C%E5%8F%89%E6%A0%91/" title="007_二叉树">https://how2051.github.io/2024/11/03/007-二叉树/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/11/03/006-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;ooo.0x0.ooo&#x2F;2023&#x2F;12&#x2F;08&#x2F;OAE0e6.jpg" title="006_栈与队列"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Leetcode</span><h3>006_栈与队列</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">一、理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E9%80%92%E5%BD%92%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 递归法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#i-%E9%80%92%E5%BD%92%E6%B3%95%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">i、递归法前序遍历：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#i-%E9%80%92%E5%BD%92%E6%B3%95%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">i、递归法中序遍历：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#i-%E9%80%92%E5%BD%92%E6%B3%95%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.3.</span> <span class="toc-text">i、递归法后序遍历：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 迭代法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#i-%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">i、迭代法前序遍历：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#i-%E8%BF%AD%E4%BB%A3%E6%B3%95%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.2.</span> <span class="toc-text">i、迭代法中序遍历：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#i-%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.3.</span> <span class="toc-text">i、迭代法后序遍历：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E7%BB%9F%E4%B8%80%E7%89%88%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 统一版迭代法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#i-%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%BB%9F%E4%B8%80%E7%89%88%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">i、迭代法统一版前序遍历：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#i-%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%BB%9F%E4%B8%80%E7%89%88%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.2.</span> <span class="toc-text">i、迭代法统一版中序遍历：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#i-%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%BB%9F%E4%B8%80%E7%89%88%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.3.</span> <span class="toc-text">i、迭代法统一版后序遍历：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.</span> <span class="toc-text">2.0 层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-%E5%85%B6%E4%BB%96"><span class="toc-number">1.5.</span> <span class="toc-text">3.0 其他</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#i-%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.1.</span> <span class="toc-text">i、满二叉树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E9%A2%98%E7%9B%AE%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.</span> <span class="toc-text">二、题目实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.1.</span> <span class="toc-text">1、144. 二叉树的前序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.</span> <span class="toc-text">2、94. 二叉树的中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.</span> <span class="toc-text">3、145. 二叉树的后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.4.</span> <span class="toc-text">4、102. 二叉树的层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.5.</span> <span class="toc-text">5、226. 翻转二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.6.</span> <span class="toc-text">6、101. 对称二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">2.7.</span> <span class="toc-text">7、104. 二叉树的最大深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-559-n-%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">2.8.</span> <span class="toc-text">8、559. N 叉树的最大深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-number">2.9.</span> <span class="toc-text">9、111. 二叉树的最小深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number">2.10.</span> <span class="toc-text">10、222. 完全二叉树的节点个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.11.</span> <span class="toc-text">11、110. 平衡二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-number">2.12.</span> <span class="toc-text">12、257. 二叉树的所有路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-number">2.13.</span> <span class="toc-text">13、404. 左叶子之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-number">2.14.</span> <span class="toc-text">14、513. 找树左下角的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-number">2.15.</span> <span class="toc-text">15、112. 路径总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.16.</span> <span class="toc-text">16、106. 从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.17.</span> <span class="toc-text">17、654. 最大二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.18.</span> <span class="toc-text">18、617. 合并二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-number">2.19.</span> <span class="toc-text">19、700. 二叉搜索树中的搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">2.20.</span> <span class="toc-text">20、98. 验证二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="toc-number">2.21.</span> <span class="toc-text">21、530. 二叉搜索树的最小绝对差</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-number">2.22.</span> <span class="toc-text">22、501. 二叉搜索树中的众数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">2.23.</span> <span class="toc-text">23、236. 二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">2.24.</span> <span class="toc-text">24、235. 二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">2.25.</span> <span class="toc-text">25、701. 二叉搜索树中的插入操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">2.26.</span> <span class="toc-text">26、450. 删除二叉搜索树中的节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27-669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">2.27.</span> <span class="toc-text">27、669. 修剪二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">2.28.</span> <span class="toc-text">28、108. 将有序数组转换为二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29-538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="toc-number">2.29.</span> <span class="toc-text">29、538. 把二叉搜索树转换为累加树</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2024/10/26/001-%E6%95%B0%E7%BB%84/" rel="bookmark" title="001_数组">001_数组</a></li><li><a href="/2024/10/26/002-%E9%93%BE%E8%A1%A8/" rel="bookmark" title="002_链表">002_链表</a></li><li><a href="/2024/10/26/003-%E5%93%88%E5%B8%8C%E8%A1%A8/" rel="bookmark" title="003_哈希表">003_哈希表</a></li><li><a href="/2024/11/03/006-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" rel="bookmark" title="006_栈与队列">006_栈与队列</a></li><li class="active"><a href="/2024/11/03/007-%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="bookmark" title="007_二叉树">007_二叉树</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Rick" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Rick</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">30</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">4</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hvdzIwNTE=" title="https:&#x2F;&#x2F;github.com&#x2F;how2051"><i class="ic i-github"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmNoZW5oYW9fcHVibGljQDE2My5jb20=" title="mailto:chenhao_public@163.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Rick @ R1ck's Playground</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">286k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:20</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/11/03/007-二叉树/",favicon:{show:"欢迎回来~",hide:"等你回来~"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->